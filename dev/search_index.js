var documenterSearchIndex = {"docs":
[{"location":"manipulating_strings/#Manipulating-Pauli-strings","page":"Manipulating single strings","title":"Manipulating Pauli strings","text":"Here is a short tutorial on the PauliString type that encodes a single Pauli string. It's more efficient to use this type than an Operator that stores a single string..","category":"section"},{"location":"manipulating_strings/#Initializing-single-Pauli-strings","page":"Manipulating single strings","title":"Initializing single Pauli strings","text":"The type PauliStrings{N, T} represents a single Pauli string acting on N spins. T is the integer type used to store the binary representation of the string. A single Pauli string can be initialized from a string:\n\nusing PauliStrings\ns = PauliString(\"1Z1Y\")\nprintln(typeof(s))\nprintln(s)\n\nor from a list of operators and their site index. In this case, we need to specify the number of sites N, here N=20:\n\ns = PauliString{20}(\"Z\", 2, \"Y\", 10)\nprintln(typeof(s))\nprintln(s)\n\nTHe binary representation consists of two integers  (bitstrings) v, w. The couple v_i, w_i  encodes the operator acting on site i. The mapping is as follows: X to (1,0), Y to (1,1), Z to (0,1), 1 to (0,0).\n\nFor example, the string \"Y1Z1\" is represented by v = 0101_2 = 5 and w = 0001_2 = 1:\n\ns = PauliString{4}(5, 1)\nprintln(s)\nprintln(s.v, \" \", s.w)\n\n(note that the strings are printed with the least significant site on the left while the least significant bit is on the right in the binary representation).","category":"section"},{"location":"manipulating_strings/#Iterate-over-all-strings-of-an-operator","page":"Manipulating single strings","title":"Iterate over all strings of an operator","text":"The strings are stored in o.strings and the coefficients in o.coeffs. Note that o.coeffs also stores a phase that counts the number of Y in the string, to get a list of coefficients, use get_coeffs. We can iterate over all strings of an operator o as follows:\n\no = rand_local2(2)\nfor string in o.strings\n    println(string)\nend","category":"section"},{"location":"manipulating_strings/#Operations-between-operators-and-single-strings","page":"Manipulating single strings","title":"Operations between operators and single strings","text":"A sum of strings is an operator:\n\no = PauliString(\"1Z1Y\") + PauliString(\"1Z1Z\")\nprintln(typeof(o))\nprintln(o)\n\nThe main operations, like +, - *, commutator, trace_product are defined between operators and single strings. For example:\n\nN = 4\no = Operator(4)\no += \"X1Y1\"\no += \"Y1Z1\"\ns = PauliString(\"ZZZZ\")\nprintln(commutator(s,o))","category":"section"},{"location":"manipulating_strings/#Translation-symmetric-Pauli-strings","page":"Manipulating single strings","title":"Translation symmetric Pauli strings","text":"The type PauliStringTS{Ls} represents a translation symmetric sum of Pauli strings where the tuple Ls specifies the period in each dimension. For example PauliStringTS{(4,)} represents a translation symmetric sum of Pauli strings on a 1D lattice of length 4, while PauliStringTS{(2,2)} represents a translation symmetric sum of Pauli strings on a 2D lattice of size 2x2. When printed, only a representative of the equivalence class under translation is shown. As above, most operations are defined between translation symmetric strings and other translation symmetric strings or translation symmetric operators. We can construct a PauliStringTS out of a String a PauliString, or a tuple of Paulis and indices:\n\ns1 = PauliString(\"X1Y1\")\ns1ts = PauliStringTS{(4,)}(s1)\nprintln(s1ts)\nprintln(typeof(s1ts))\n\ns2ts = PauliStringTS{(4,)}(\"XX1X\")\nprintln(s2ts)\n\ns3ts = PauliStringTS{(5,)}(\"X\", 1, \"Y\", 4)\nprintln(s3ts)\n\nNote a PauliStringTS represent a sum of strings, so when computing the commutation of two PauliStringTS, the result is not necessarilly a single string and is returned as an OperatorTS:\n\nsts1 = PauliStringTS{(4,)}(\"XX11\")\nsts2 = PauliStringTS{(4,)}(\"ZZ11\")\no = commutator(sts1, sts2)\nprintln(o)\nprintln(typeof(o))","category":"section"},{"location":"symbolics/#Symbolics","page":"Symbolics","title":"Symbolics","text":"In this tutorial, we show how to work with symbolic operators using the Symbolics.jl package. Make sure you have Symbolics.jl installed.","category":"section"},{"location":"symbolics/#Construction-and-basic-operations","page":"Symbolics","title":"Construction and basic operations","text":"First import the necessary packages:\n\nusing Symbolics\nusing PauliStrings\n\nDefine a symbolic Operator type where coefficients are Complex{Symbolics.Num}:\n\nOperatorSymbolic(N::Int) = Operator{paulistringtype(N),Complex{Num}}()\n\nInitialize an empty 2-qubit symbolic operator:\n\nN = 2\nH = OperatorSymbolic(N)\nprintln(typeof(H))\n\nOperator{PauliString{2, UInt8}, Complex{Num}}\n\nNow let's create a two-site Ising model, where the value of the transverse field is a symbolic variable h\n\n@variables h\nH += \"Z\", 1, \"Z\", 2\nH += h, \"X\", 1\nH += h, \"X\", 2\n\nWe can perform the usual operations supported for Operator\n\nprintln(H)\nprintln(H + H + 0.5)\nprintln(trace_product(H, 4))\n\n(h) 1X\n(h) X1\n(1.0) ZZ\n\n(0.5) 11\n(2h) 1X\n(2h) X1\n(2.0) ZZ\n\n4.0(4(h^4) + (1 + 2(h^2))^2)","category":"section"},{"location":"symbolics/#Simplification-of-symbolic-operators","page":"Symbolics","title":"Simplification of symbolic operators","text":"Here is a helper function that simplifies a symbolic operator:\n\n\"\"\"\nSimplifies an Operator defined with symbolic coefficients. Uses `Symbolics.simplify` to simplify the symbolic\nexpressions in each of the coefficients of `o`. Returns a new `Operator`.\n\"\"\"\nfunction simplify_op(o::Operator)\n    o2 = typeof(o)()\n    for i in 1:length(o)\n        c = simplify(o.coeffs[i])\n        if !iszero(c)\n            push!(o2.coeffs, c)\n            push!(o2.strings, o.strings[i])\n        end\n    end\n    return o2\nend\n\nLet's apply this to H^2:\n\nH2 = H^2\nprintln(H2)\nprintln(simplify_op(H2))\n\n(1 + 2(h^2)) 11\n(0.0) ZY\n(0.0) YZ\n(2(h^2)) XX\n\n(1 + 2(h^2)) 11\n(2(h^2)) XX\n\nHowever, keep in mind that simplify doesn't reduce all the expressions:\n\nH3 = H^3\nprintln(H3)\nprintln(simplify_op(H3))\n\n(2(h^3) + h*(1 + 2(h^2))) 1X\n(-2.0(h^2)) YY\n(2(h^3) + h*(1 + 2(h^2))) X1\n(1 + 2(h^2)) ZZ\n\n(2(h^3) + h*(1 + 2(h^2))) 1X\n(-2.0(h^2)) YY\n(2(h^3) + h*(1 + 2(h^2))) X1\n(1 + 2(h^2)) ZZ\n\nAs a final example, let's calculate some commutators with another operator O\n\nO1 = OperatorSymbolic(N)\nO1 += \"X\", 1\nO2 = commutator(H, O1)\nO3 = commutator(H, O2)\nprintln(O2)\nprintln(O3)\n\n(2.0im) YZ\n\n(4.0h) YY\n(4.0) X1\n(-4h) ZZ","category":"section"},{"location":"symbolics/#Substituting-variables-with-numericald-values","page":"Symbolics","title":"Substituting variables with numericald values","text":"\"\"\"\nSubstitutes some or all of the variables in `o` according to the rule(s) in dict.\nIf all the substitutions are to concrete numeric values, then it will return an `Operator` with\n`Complex64` coefficients.\n\"\"\"\nfunction substitute_op(o::Operator, dict::Dict)\n    o = simplify_op(o)\n    ps, cs = o.strings, o.coeffs\n    cs_expr = substitute.(o.coeffs, (dict,))\n    cs_vals = ComplexF64[]\n\n    # Attempt to convert all the coefficients to ComplexF64, not possible if one or more variables remained unassigned\n    all_vals = true\n    for c in cs_expr\n        try\n            push!(cs_vals, ComplexF64(Symbolics.value(c)))\n        catch\n            all_vals = false\n            break\n        end\n    end\n\n    if all_vals\n        return Operator{paulistringtype(qubitlength(o)),ComplexF64}(copy(ps), cs_vals)\n    else\n        return Operator{paulistringtype(qubitlength(o)),Complex{Num}}(copy(ps), cs_expr)\n    end\nend\n\nTo substitute the variables for concrete numerical values we use substitute_op\n\nO = substitute_op(O3, Dict(h => 0.5))\nprintln(typeof(O))\nprintln(O)\n\nOperator{PauliString{2, UInt8}, ComplexF64}\n(2.0 - 0.0im) YY\n(4.0 + 0.0im) X1\n(-2.0 + 0.0im) ZZ","category":"section"},{"location":"circuits/#Quantum-circuits","page":"Circuits","title":"Quantum circuits","text":"The module Circuits provides a way to construct and simulate circuits. Initialise an empty circuit with Circuit(n) where n is the number of qubits. Then, add gates to the circuit with push!(circuit, gate, qubits...) where gate is a string representing the gate and qubits are the qubits the gate acts on. For example, a CNOT gate with control qubit 1 and target qubit 2 is added to the circuit c with push!(c, \"CNOT\", 1, 2). Depolarizing noise can be added to the circuit with push!(c, \"Noise\"). The noise amplitude can be set with c.noise_amplitude=p.\n\nLets construct a CCX gate (Toffoli gate) out of CNOT and single qubit gates.\n\nusing PauliStrings\nusing PauliStrings.Circuits\n\nfunction noisy_toffoli()\n    c = Circuit(3)\n    push!(c, \"H\", 3)\n    push!(c, \"CNOT\", 2, 3); push!(c, \"Noise\")\n    push!(c, \"Tdg\", 3)\n    push!(c, \"CNOT\", 1, 3); push!(c, \"Noise\")\n    push!(c, \"T\", 3)\n    push!(c, \"CNOT\", 2, 3); push!(c, \"Noise\")\n    push!(c, \"Tdg\", 3)\n    push!(c, \"CNOT\", 1, 3); push!(c, \"Noise\")\n    push!(c, \"T\", 2)\n    push!(c, \"T\", 3)\n    push!(c, \"CNOT\", 1, 2); push!(c, \"Noise\")\n    push!(c, \"H\", 3)\n    push!(c, \"T\", 1)\n    push!(c, \"Tdg\", 2)\n    push!(c, \"CNOT\", 1, 2); push!(c, \"Noise\")\n    return c\nend\n\nWe can plot the circuit using QuantumCircuitDraw.jl:\n\nusing QuantumCircuitDraw\nc = noisy_toffoli()\npaulistrings_plot(c)\n\n(Image: plot)\n\nThe circuit can be compiled to a unitary matrix with compile(c). Before compiling, set c.noise_amplitude to the desired noise amplitude and c.max_strings to the number of strings to keep at each step. Compile will multiply the gates in the circuit from left to right, apply the noise using add_noise and trim the operator at each step using trim.\n\nLets check our Toffoli gate against the built-in CCX gate in Circuits:\n\nusing PauliStrings.Circuits\nusing LinearAlgebra: norm\nc = noisy_toffoli()\nc.noise_amplitude = 0\nU1 = compile(c)\nU2 = CCXGate(3,1,2,3)\nprintln(norm(U1-U2))\n\nWe can also compute expectation values of states in the computational basis with expect(c, state_out) and expect(c, state_in, state_out) . Let's compute the expectation values of the output states of the Toffoli gate when the input state is 111rangle:\n\nin_state = \"111\"\nout_states = [\"000\", \"001\", \"010\", \"011\", \"100\", \"101\", \"110\", \"111\"]\np = [real(expect(c, in_state, out_state)) for out_state in out_states]\nusing Plots\nbar(out_states, p, legend=false, xlabel=\"out state\", ylabel=\"<out|U|in>\")\n\nSame as above but seting the noise amplitude to 0.05:\n\nc.noise_amplitude = 0.05\np = [real(expect(c, in_state, out_state)) for out_state in out_states]\nbar(out_states, p, legend=false, xlabel=\"out state\", ylabel=\"<out|U|in>\")","category":"section"},{"location":"lanczos/#Lanczos","page":"Lanczos","title":"Lanczos","text":"Here we show how to use PauliStrings.jl to run the recursion method and compute lanczos coefficients. We will focus on reproducing the X in XX results from figure 2 of Parker 2019.\n\nStart by importing PauliStrings:\n\nusing PauliStrings\nimport PauliStrings as ps\n\nDefine the XX Hamiltonian H = sum_i X_iX_i+1+Y_iY_i+1 on a 1D chain with periodic boundary conditions\n\nfunction XX(N)\n    H = ps.Operator(N)\n    for j in 1:(N - 1)\n        H += \"X\",j,\"X\",j+1\n        H += \"Z\",j,\"Z\",j+1\n    end\n    H += \"X\",1,\"X\",N\n    H += \"Z\",1,\"Z\",N\n    return H\nend\n\nand the X operator sum_i=1^N X_i\n\nfunction X(N)\n    H = ps.Operator(N)\n    for j in 1:N\n        H += \"X\",j\n    end\n    return H\nend\n\nInitialize a Hamiltonian and an operator:\n\nN = 50 # system size\nH = XX(N) # Hamiltonian\nO = X(N) # operator\n\nnothing # hide\n\nCompute and plot the lanczos coefficients for different truncations. For each level of truncation, we keep only 2^p terms with the highest weight at each step of the lanczos algorithm.\n\nioff() # pyplot\n# nterms is the max pauli string length\nfor p in (14,16,18,20)\n    @time bs = ps.lanczos(H, O, 20, 2^p; keepnorm=true)\n    plot(bs, label=\"trim: 2^$p\")\nend\nlegend()\nylabel(L\"$b_n$\")\nxlabel(L\"$n$\")\ntitle(\"X in XX, N=$N spins\")\nsavefig(\"lanczos_example.png\")\nshow()\n\n(Image: plot)","category":"section"},{"location":"lanczos/#Tacking-advantage-of-translation-symmetry","page":"Lanczos","title":"Tacking advantage of translation symmetry","text":"If the problem has translation symmetry, we can take advantage of the symmetry to save time and memory. Just pass O and H as OperatorTS to lanczos. For example:\n\np=14\nHts = OperatorTS{(N,)}(H)\nOts = OperatorTS{(N,)}(O)\nbs = ps.lanczos(Hts, Ots, 20, 2^p; keepnorm=true, show_progress=false)\n\nnothing # hide\n\nCheck the translation symmetry tutorial.","category":"section"},{"location":"docstrings_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"evolution/#Time-evolution","page":"Time evolution","title":"Time evolution","text":"Time evolution with PauliStrings.jl is done in the Heisenberg picture. The method is commonly referred to as sparse Pauli dynamics, Pauli paths simulation, Pauli propagation or Pauli backpropagation.\n\nThe advantage of working with Pauli strings is that noisy systems can be efficiently simulated in this representation (Schuster 2024). Depolarizing noise makes long strings decay, so we can make the simulations tractable by combining noise with truncation.\n\nLet's time evolve operator Z_1 in the chaotic spin chain\n\nH = sum_i X_i X_i+1-105 Z_i +h_X X_i\n\nFirst we construct the Hamiltonian:\n\nusing PauliStrings\nimport PauliStrings as ps\n\nfunction chaotic_chain(N::Int)\n    H = ps.Operator(N)\n    # XX interactions\n    for j in 1:(N - 1)\n        H += \"X\",j,\"X\",j+1\n    end\n    H += \"X\",1,\"X\",N # close the chain\n    # fields\n    for j in 1:N\n        H += -1.05,\"Z\",j\n        H += 0.5,\"X\",j\n    end\n    return H\nend\n\nWe initialize a Hamiltonian and the Z_1 operator on a 32 spins system.\n\nN = 32 # system size\nH = chaotic_chain(N) # Hamiltonian\nO = ps.Operator(N) # operator to time evolve\nO += \"Z\", 1 # Z on site 1\n\nNow we write a function that will time evolve operator O under Hamiltonian H and return some observable. Here we are interested in recording the correlator\n\nS(t) = frac12^N textTr Z_1(t)Z_1(0)\n\nWe will time evolve O by integrating Von Neuman's equation i fracdOdt=-HO with Runge-Kutta (rk4). At each time step we do 3 things :\n\nPerform a rk4 step\nadd_noise that makes long strings decay\ntrim O by keeping only M strings with the largest weight\n\n# heisenberg evolution of the operator O using rk4\n# return tr(O(0)*O(t))/tr(O(t)^2)\n# M is the number of strings to keep at each step\n# noise is the amplitude of depolarizing noise\nusing ProgressBars\n\nfunction evolve(H, O, M, times, noise)\n    echo = []\n    O0 = deepcopy(O)\n    dt = times[2]-times[1]\n    for t in ProgressBar(times)\n        push!(echo, ps.trace(O*ps.dagger(O0))/ps.trace(O0*O0))\n        # perform one step of rk4, keep only M strings, do not discard O0\n        O = ps.rk4(H, O, dt; heisenberg=true, M=M,  keep=O0)\n        # add depolarizing oise\n        O = ps.add_noise(O, noise*dt)\n        # keep the M strings with the largest weight. Do not discard O0\n        O = ps.trim(O, M; keep=O0)\n    end\n    return real.(echo)\nend\n\nNow we can actually time evolve O for different trim values and plot the result:\n\n# time evolve O for different trim values\ntimes = range(0, stop=5, step=0.05)\nnoise = 0.01\nfor trim in (10,12,14)\n    S = evolve(H, O, 2^trim, times, noise)\n    loglog(times, S) #plot S(t)\nend\n\nlegend()\ntitle(\"N=$N\")\nxlabel(\"t\")\nylabel(L\"tr$(Z_1(0)*Z_1(t))$\")\nsavefig(\"time_evolve_example.png\")\nshow()\n\n(Image: plot)","category":"section"},{"location":"translation/#translation","page":"Translation symmetry","title":"Translation symmetry with OperatorTS","text":"Here we will show how to take advantage of translation symmetry to save time and memory in PauliStrings.jl. Consider the 1D Ising Hamiltonian with periodic boundary conditions H=-J(sum_iZ_i Z_i+1 +g sum_i X_i). There is no need to actually store all the Pauli strings in this case. H is fully specified by just -JZ_1Z_2 and -Jg X_1 and the fact that it's translation symmetric.\n\nIn general, a 1D translation symmetric operator can be written as sum_i T_i H_0 where T_i is the i-sites translation operator and H_0 is the local operator that generates H. H_0 can be chosen so that it's only composed of Pauli strings that start on the first site.\n\nIn PauliStrings.jl, the structure OperatorTS lets you manipulate operators in this format. If your problem is translation symmetric, OperatorTS will be much faster than Operator.","category":"section"},{"location":"translation/#Construction","page":"Translation symmetry","title":"Construction","text":"The constructor of OperatorTS takes a normal operator and turns it into a lazy sum over all possible translations. There are two ways of using this constructor.","category":"section"},{"location":"translation/#From-the-full-translation-symmetric-H","page":"Translation symmetry","title":"From the full translation symmetric H","text":"First we construct the full Operator:\n\nfunction ising1D(N, J, g)\n    H = Operator(N)\n    for j in 1:(N - 1)\n        H += \"Z\",j,\"Z\",j+1\n    end\n    H += \"Z\",1,\"Z\",N #periodic boundary condition\n    for j in 1:N\n        H += g,\"X\",j\n    end\n    return -J*H\nend\nN = 4\nJ = -1.0\ng = 1.0\n\nH = ising1D(N, J, g)\n\nthen convert it to an OperatorTS\n\nHts = OperatorTS{(N,)}(H)/N\n\n# output\n\n(1.0 + 0.0im) 111X\n(1.0 + 0.0im) 11ZZ\n\nNote the normalization factor 1/N that normalizes the symmetric sum. We can use is_ts to check if H is actually symmetric.","category":"section"},{"location":"translation/#From-the-local-generator-H_0","page":"Translation symmetry","title":"From the local generator H_0","text":"Construct H_0 using Operator:\n\nH = Operator(N)\nH += -J, \"Z\",1,\"Z\",2\nH += -J*g,\"X\",1\n\nthen convert it to an OperatorTS\n\nHts = OperatorTS{(N,)}(H)\n\n# output\n\n(1.0 + 0.0im) 111X\n(1.0 + 0.0im) 11ZZ\n\nIn this case, no normalization factor is needed.","category":"section"},{"location":"translation/#Manipulation","page":"Translation symmetry","title":"Manipulation","text":"All the operations defined on Operator are also defined on OperatorTS.\n\nConstruct a simple translation invariant operator on 4 sites:\n\nH = Operator(N)\nH += \"X\", 1\nH += \"Z\", 1,\"Z\", 2\n\nHts = OperatorTS{(N,)}(H)\n\nprintln(H)\nprintln(resum(Hts))\n\n# output\n\n(1.0 + 0.0im) X111\n(1.0 + 0.0im) ZZ11\n\n(1.0 + 0.0im) X111\n(1.0 + 0.0im) 1X11\n(1.0 + 0.0im) 11X1\n(1.0 + 0.0im) 111X\n(1.0 + 0.0im) ZZ11\n(1.0 + 0.0im) 1ZZ1\n(1.0 + 0.0im) Z11Z\n(1.0 + 0.0im) 11ZZ\n\nNote that only the local generator is printed when printing OperatorTS, not the full operator.\n\nMultiplication:\n\njulia> Hts*Hts\n(1.0 + 0.0im) 1X1X\n(1.0 + 0.0im) ZZZZ\n(2.0 + 0.0im) 1111\n(2.0 + 0.0im) 11XX\n(2.0 + 0.0im) 1Z1Z\n(2.0 + 0.0im) X1ZZ\n(2.0 + 0.0im) 1XZZ\n\nAddition:\n\njulia> Hts+Hts\n(2.0 + 0.0im) 111X\n(2.0 + 0.0im) 11ZZ\n\netc.","category":"section"},{"location":"translation/#Example:-computing-Tr(Hk)","page":"Translation symmetry","title":"Example: computing Tr(H^k)","text":"As an example of performance gains of using OperatorTS instead of Operator we compute the 8th moment (Tr(H^8)) of a 30 spin system.\n\nUsing the function defined above we construct a Ising Hamiltonian and convert it to an OperatorTS:\n\nN = 30\nk = 8\nH = ising1D(N, J, g)\nHts = OperatorTS{(N,)}(H)/N\n\nthen we compute the kth moment (trace_product) using both Operator and OperatorTS :\n\njulia> @time trace_product(H, k)\n  0.688497 seconds (451 allocations: 135.925 MiB, 54.67% gc time)\n1.1904927790006272e18 + 0.0im\njulia> @time trace_product(Hts, k)\n  0.038475 seconds (235 allocations: 7.023 MiB, 27.41% gc time)\n1.1904927790006272e18 + 0.0im\n\nOperatorTS is 18 times faster in this case.","category":"section"},{"location":"translation/#Translation-symmetry-in-2D","page":"Translation symmetry","title":"Translation symmetry in 2D","text":"Similar to the 1D case, a 2D translation symmetric operator can be constructed by either specifying an operator on each site, or by using a local generator. Here we construct a 2D transverse field ising model on a rectangular lattice with periodic boundary conditions with the help of the string_2d function:\n\nfunction ising2D(L1, L2, g)\n    H = Operator(L1 * L2)\n    for x in 1:L1\n        for y in 1:L2\n            H += string_2d((\"Z\", x, y, \"Z\", x + 1, y), L1, L2, pbc=true) # horizontal\n            H += string_2d((\"Z\", x, y, \"Z\", x, y + 1), L1, L2, pbc=true) # vertical\n            H += g * string_2d((\"X\", x, y), L1, L2, pbc=true) # transverse field\n        end\n    end\n    return H\nend\nL1 = 3\nL2 = 2\n\njulia> H = ising2D(L1, L2, 0.5)\n(0.5 + 0.0im) X11111\n(0.5 + 0.0im) 1X1111\n(0.5 + 0.0im) 11X111\n(0.5 + 0.0im) 111X11\n(0.5 + 0.0im) 1111X1\n(0.5 + 0.0im) 11111X\n(1.0 + 0.0im) ZZ1111\n(1.0 + 0.0im) Z1Z111\n(1.0 + 0.0im) 1ZZ111\n(1.0 + 0.0im) 111ZZ1\n(1.0 + 0.0im) 111Z1Z\n(1.0 + 0.0im) 1111ZZ\n(2.0 + 0.0im) Z11Z11\n(2.0 + 0.0im) 1Z11Z1\n(2.0 + 0.0im) 11Z11Z\n\nIn general, if you have a lattice with extents L_1 L_2 in the a_1 and a_2 directions respectively, a PauliString is written in column-major order (similar to how a matrix is flattened in Julia), that is, L_2 concatenated chunks of length L_1 each.\n\nTo convert to an OperatorTS, in higher dimensions we have to specify the size of the lattice.\n\njulia> Hts = OperatorTS{(L1, L2)}(H)/(L1*L2)\n(0.5 + 0.0im) 111\n              11X\n(1.0 + 0.0im) 11Z\n              11Z\n(1.0 + 0.0im) 111\n              1ZZ\n\nAlternatively, you can also specify the local generator only:\n\nH0 = Operator(L1 * L2)\nH0 += 1.0 * string_2d((\"Z\", 1, 1, \"Z\", 2, 1), L1, L2)\nH0 += 1.0 * string_2d((\"Z\", 1, 1, \"Z\", 1, 2), L1, L2)\nH0 += 0.5 * string_2d((\"X\", 1, 1), L1, L2)\n\njulia> Hts = OperatorTS{(L1,L2)}(H0)\n(0.5 + 0.0im) 111\n              11X\n(1.0 + 0.0im) 11Z\n              11Z\n(1.0 + 0.0im) 111\n              1ZZ","category":"section"},{"location":"#Getting-started","page":"Getting started","title":"Getting started","text":"(Image: Build Status) (Image: ) (Image: ) (Image: ) (Image: )\n\nPauliStrings.jl is a Julia package for many-body quantum mechanics with Pauli string represented as binary integers. It is particularly adapted for running Lanczos, time evolving noisy systems and simulating spin systems on arbitrary graphs. Paper : https://arxiv.org/abs/2410.09654, Python version\n\n(Image: gif)","category":"section"},{"location":"#[Documentation](https://paulistrings.org/dev/)","page":"Getting started","title":"Documentation","text":"The documentation is there : https://paulistrings.org\n\nTo build the docs :\n\njulia docs/make.jl","category":"section"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"You can install the package using Julia's package manager\n\nusing Pkg; Pkg.add(\"PauliStrings\")\n\nOr\n\n] add PauliStrings","category":"section"},{"location":"#Initializing-an-operator","page":"Getting started","title":"Initializing an operator","text":"Import the library and initialize a operator of 4 qubits\n\nimport PauliStrings as ps\nH = ps.Operator(4)\n\nAdd a Pauli string to the operator\n\nH += \"XYZ1\"\nH += \"1YZY\"\n\njulia> H\n(1.0 - 0.0im) XYZ1\n(1.0 - 0.0im) 1YZY\n\nAdd a Pauli string with a coefficient\n\nH += -1.2, \"XXXZ\" # coefficient can be complex\n\nAdd a 2-qubit string coupling qubits i and j with X and Y:\n\nH += 2, \"X\", i, \"Y\", j # with a coefficient=2\nH += \"X\", i, \"Y\", j # with a coefficient=1\n\nAdd a 1-qubit string:\n\nH += 2, \"Z\", i # with a coefficient=2\nH += \"Z\", i # with a coefficient=1\nH += \"S+\", i\n\nSupported sites operators are X, Y, Z, Sx=X2, Sy=Y2, Sz=Z2, S+=(X+iY)2, S-=(X-iY)2.","category":"section"},{"location":"#Basic-Algebra","page":"Getting started","title":"Basic Algebra","text":"The Operator type supports the +,-,* operators with other Operators and Numbers:\n\nH3 = H1*H2\nH3 = H1+H2\nH3 = H1-H2\nH3 = H1+2 # adding a scalar is equivalent to adding the unit times the scalar\nH = 5*H # multiply operator by a scalar\n\nTrace : ps.trace(H)\n\nFrobenius norm : ps.opnorm(H)\n\nConjugate transpose : ps.dagger(H)\n\nNumber of terms: length(H)\n\nCommutator: ps.com(H1, H2). This is much faster than H1*H2-H2*H1","category":"section"},{"location":"#Print-and-export","page":"Getting started","title":"Print and export","text":"print shows a list of terms with coefficients e.g:\n\njulia> println(H)\n(10.0 - 0.0im) 1ZZ\n(5.0 - 0.0im) 1Z1\n(15.0 + 0.0im) XYZ\n(5.0 + 0.0im) 1YY\n\nExport a list of strings with coefficients:\n\ncoefs, strings = ps.op_to_strings(H)","category":"section"},{"location":"#Truncate,-Cutoff,-Trim,-Noise","page":"Getting started","title":"Truncate, Cutoff, Trim, Noise","text":"ps.truncate(H,M) removes Pauli strings longer than M (returns a new Operator) ps.cutoff(H,c) removes Pauli strings with coefficient smaller than c in absolute value (returns a new Operator) ps.trim(H,N) keeps the first N trings with higest weight (returns a new Operator) ps.prune(H,alpha) keeps terms with probability 1-exp(-alpha*abs(c)) (returns a new Operator)\n\nps.add_noise(H,g) adds depolarizing noise that make each strings decay like e^gw where w is the length of the string. This is useful when used with trim to keep the number of strings manageable during time evolution.","category":"section"},{"location":"#Time-evolution","page":"Getting started","title":"Time evolution","text":"Time evolution in the Pauli strings basis is commonly referred to as sparse Pauli dynamics, Pauli paths simulation, Pauli propagation or Pauli backpropagation.\n\nps.rk4(H, O, dt; hbar=1, heisenberg=false) performs a step of Runge Kutta and returns the new updated O(t+dt)\n\nH can be an Operator, or a function that takes a time and return an Operator. In case H is a function, a time also needs to be passed to rk4(H, O, dt, t). O is an Observable or a density matrix to time evolve. If evolving an observable in the Heisenberg picture, set heisenberg=true.\n\nAn example is in time_evolve_example.jl. The following will time evolve O in the Heisenberg picture. At each step, we add depolarizing noise and trim the operator to keep the number of strings manageable\n\nfunction evolve(H, O, M, times, noise)\n    dt = times[2]-times[1]\n    for t in times\n        O = ps.rk4(H, O, dt; heisenberg=true, M=M) # perform one step of rk4, keep only M strings\n        O = ps.add_noise(O, noise*dt) # add depolarizing noise\n        O = ps.trim(O, M) # keep the M strings with the largest weight\n    end\n    return O\nend\n\nTime evolution of the spin correlation function textupTr(Z_1(0)Z_1(t)) in the chaotic spin chain. Check timeevolveexample.jl to reproduce the plot. (Image: plot)","category":"section"},{"location":"#Lanczos","page":"Getting started","title":"Lanczos","text":"Compute lanczos coefficients\n\nbs = ps.lanczos(H, O, steps, nterms)\n\nH : Hamiltonian\n\nO : starting operator\n\nnterms : maximum number of terms in the operator. Used by trim at every step\n\nResults for X in XX from https://journals.aps.org/prx/pdf/10.1103/PhysRevX.9.041017 :\n\n(Image: plot)","category":"section"},{"location":"#Circuits","page":"Getting started","title":"Circuits","text":"The module Circuits provides an easy way to construct and simulate circuits. Construct a Toffoli gate out elementary gates:\n\nusing PauliStrings\nusing PauliStrings.Circuits\n\nfunction noisy_toffoli()\n    c = Circuit(3)\n    push!(c, \"H\", 3)\n    push!(c, \"CNOT\", 2, 3); push!(c, \"Noise\")\n    push!(c, \"Tdg\", 3)\n    push!(c, \"CNOT\", 1, 3); push!(c, \"Noise\")\n    push!(c, \"T\", 3)\n    push!(c, \"CNOT\", 2, 3); push!(c, \"Noise\")\n    push!(c, \"Tdg\", 3)\n    push!(c, \"CNOT\", 1, 3); push!(c, \"Noise\")\n    push!(c, \"T\", 2)\n    push!(c, \"T\", 3)\n    push!(c, \"CNOT\", 1, 2); push!(c, \"Noise\")\n    push!(c, \"H\", 3)\n    push!(c, \"T\", 1)\n    push!(c, \"Tdg\", 2)\n    push!(c, \"CNOT\", 1, 2); push!(c, \"Noise\")\n    return c\nend\n\n(Image: plot)\n\nCompute the expectation value 110U111:\n\nc = noisy_toffoli()\nexpect(c, \"111\", \"110\")","category":"section"},{"location":"#Contributing,-Contact","page":"Getting started","title":"Contributing, Contact","text":"Contributions are welcome! Feel free to open a pull request if you'd like to contribute code or documentation. For bugs and feature requests, please open an issue. For questions, you can either contact nicolas.loizeau@nbi.ku.dk or start a new discussion in the repository.","category":"section"},{"location":"#Citation","page":"Getting started","title":"Citation","text":"@Article{Loizeau2025,\n\ttitle={{Quantum many-body simulations with PauliStrings.jl}},\n\tauthor={Nicolas Loizeau and J. Clayton Peacock and Dries Sels},\n\tjournal={SciPost Phys. Codebases},\n\tpages={54},\n\tyear={2025},\n\tpublisher={SciPost},\n\tdoi={10.21468/SciPostPhysCodeb.54},\n\turl={https://scipost.org/10.21468/SciPostPhysCodeb.54},\n}\n\n@Article{Loizeau2025,\n\ttitle={{Codebase release 1.5 for PauliStrings.jl}},\n\tauthor={Nicolas Loizeau and J. Clayton Peacock and Dries Sels},\n\tjournal={SciPost Phys. Codebases},\n\tpages={54-r1.5},\n\tyear={2025},\n\tpublisher={SciPost},\n\tdoi={10.21468/SciPostPhysCodeb.54-r1.5},\n\turl={https://scipost.org/10.21468/SciPostPhysCodeb.54-r1.5},\n}","category":"section"},{"location":"constructing/#Constructing-operators","page":"Constructing operators","title":"Constructing operators","text":"Start by importing PauliStrings:\n\nusing PauliStrings\nimport PauliStrings as ps\n\nTo construct an operator we first need to declare an empty operator of N qubits:\n\nH = Operator(N)\n\nPauliStrings.jl supports up to 1024 qubits.\n\nWe can add a term of the form J X_i by doing\n\nH += J, \"X\", i\n\nand a term of the form J X_iX_j by doing\n\nH += J, \"X\", i, \"X\", j\n\nSimilarly, we add a term of the form J X_iX_jX_k by doing\n\nH += J, \"X\", i, \"X\", j, \"X\", k\n\netc.","category":"section"},{"location":"constructing/#1D-transverse-Ising-model","page":"Constructing operators","title":"1D transverse Ising model","text":"Let's construct the Hamiltonian of a 1D transverse Ising model H=-J(sum_ijZ_i Z_j +g sum_i X_i)\n\nfunction ising1D(N, J, g)\n    H = Operator(N)\n    for j in 1:(N - 1)\n        H += \"Z\",j,\"Z\",j+1\n    end\n    H += \"Z\",1,\"Z\",N # periodic boundary condition\n    for j in 1:N\n        H += g,\"X\",j\n    end\n    return -J*H\nend\n\nNote that the first qubit starts at index 1, following Julia's 1-based index.\n\nOperators can be printed in strings format with the println function:\n\nprintln(ising1D(3, 1, 0.5))","category":"section"},{"location":"constructing/#2D-transverse-Ising-model","page":"Constructing operators","title":"2D transverse Ising model","text":"Here we construct a 2D Ising model on a square lattice of L*L sites, with no periodic boundary conditions.\n\nfunction ising2D(L, J, g)\n    H = ps.Operator(L * L)\n    for x in 1:L-1\n        for y in 1:L\n            # convert x,y to qubit index\n            i = L * (y - 1) + x\n            j = L * (y - 1) + (x + 1)\n            # horizontal interaction terms\n            H += (\"Z\", i, \"Z\", j)\n            # convert x,y to qubit index\n            i = L * (x - 1) + y\n            j = L * x + y\n            # vertical interaction terms\n            H += (\"Z\", i, \"Z\", j)\n        end\n    end\n    for j in 1:L*L\n        H += g, \"X\", j\n    end\n    return -J * H\nend\n\nprintln(ising2D(3, 1.0, 0.5))\n\nWe can also construct a 2d operator using the string_2d function,\n\nfunction ising2D(L, J, g)\n    H = Operator(L * L)\n    for x in 1:L\n        for y in 1:L\n            # horizontal interaction\n            (x < L) && (H += string_2d((\"Z\", x, y, \"Z\", x + 1, y), L, L))\n            # vertical interaction\n            (y < L) &&  (H += string_2d((\"Z\", x, y, \"Z\", x, y + 1), L, L))\n            # transverse field\n            H += g * string_2d((\"X\", x, y), L, L)\n        end\n    end\n    return -J * H\nend\n\nprintln(ising2D(3, 1.0, 0.5))","category":"section"},{"location":"docstrings/#Documentation","page":"Docstrings","title":"Documentation","text":"","category":"section"},{"location":"docstrings/#Basics","page":"Docstrings","title":"Basics","text":"","category":"section"},{"location":"docstrings/#Truncation-and-noise","page":"Docstrings","title":"Truncation and noise","text":"","category":"section"},{"location":"docstrings/#Algorithms","page":"Docstrings","title":"Algorithms","text":"","category":"section"},{"location":"docstrings/#Operations","page":"Docstrings","title":"Operations","text":"","category":"section"},{"location":"docstrings/#Power-and-moments","page":"Docstrings","title":"Power and moments","text":"","category":"section"},{"location":"docstrings/#Random-operators","page":"Docstrings","title":"Random operators","text":"","category":"section"},{"location":"docstrings/#Construction","page":"Docstrings","title":"Construction","text":"","category":"section"},{"location":"docstrings/#Tranlation-symmetry","page":"Docstrings","title":"Tranlation symmetry","text":"","category":"section"},{"location":"docstrings/#States","page":"Docstrings","title":"States","text":"","category":"section"},{"location":"docstrings/#Circuits","page":"Docstrings","title":"Circuits","text":"","category":"section"},{"location":"docstrings/#I/O-and-conversion","page":"Docstrings","title":"I/O and conversion","text":"","category":"section"},{"location":"docstrings/#Other-tools","page":"Docstrings","title":"Other tools","text":"","category":"section"},{"location":"docstrings/#Index","page":"Docstrings","title":"Index","text":"","category":"section"},{"location":"docstrings/#PauliStrings.Operator-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.Operator","text":"Operator(N::Integer)\n\nInitialize a zero operator on N qubits.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.OperatorTS-Union{Tuple{Any}, Tuple{Ls}} where Ls","page":"Docstrings","title":"PauliStrings.OperatorTS","text":"OperatorTS{Ls}(o::Operator)\n\nConstruct an n-dimensional translation symmetric operator from o where Ls is a tuple of integers (L1, L2, ...) The resulting operator is equivalent to\n\nO_mathrmTS = sum_T T^dag O T\n\nwhere T are all translations on the L1×L2×… hypercube. So if you feed it an operator that is already a sum, you should afterwards normalize it by the number of sites.\n\nTo get a dense operator from this lazy sum representation, see resum. To get a single term, see representative.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.qubitlength","page":"Docstrings","title":"PauliStrings.qubitlength","text":"qubitlength(x::AbstractOperator)\nqubitlength(::Type{<:AbstractOperator})\n\nReturns the number of qubits the operator acts on.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#PauliStrings.add_noise-Tuple{AbstractOperator, Real}","page":"Docstrings","title":"PauliStrings.add_noise","text":"add_noise(o::Operator, g::Real)\n\nAdd depolarizing noise that make the long string decays. g is the noise amplitude. Each string is multiplied by exp(-g * w), where w is the number of non-identity Pauli operators in the string. This is equivalent to the compostion of N single qubit depolarizing channels with Kraus operators sqrt1-frac3p4 I_i  sqrtfracp4 X_i  sqrtfracp4 Y_i  sqrtfracp4 Z_i and p=1-e^-g.\n\nExample\n\nA = add_noise(A, 0.1)\n\nReference\n\nhttps://arxiv.org/pdf/2407.12768\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.add_noise-Tuple{AbstractOperator, AbstractVector{<:Real}}","page":"Docstrings","title":"PauliStrings.add_noise","text":"add_noise(o::Operator, g::AbstractVector{<:Real})\n\nAdd local depolarizing noise.\n\nIf g_j is the noise amplitude for site j, then each string will be multiplied by e^-sum_j g_j, where the sum runs over the sites with non-unit Pauli operators.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.add_dephasing_noise-Tuple{AbstractOperator, Real}","page":"Docstrings","title":"PauliStrings.add_dephasing_noise","text":"add_dephasing_noise(o::AbstractOperator, g::Real)\n\nAdd dephasing noise.\n\nIf g is the noise amplitude, then each string will decay by a factor of e^-gw, where w is the count of Pauli operators in the string that are either X or Y.\n\nReference\n\nhttps://arxiv.org/abs/2306.05804\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.add_dephasing_noise-Tuple{AbstractOperator, AbstractVector{<:Real}}","page":"Docstrings","title":"PauliStrings.add_dephasing_noise","text":"add_dephasing_noise(o::AbstractOperator, g::AbstractVector{<:Real})\n\nAdd local dephasing noise.\n\nIf g_j is the noise amplitude of site j, then each string will be multiplied by e^-sum_j g_j, where the sum runs over the sites with Pauli operators that are either X or Y.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.truncate-Tuple{AbstractOperator, Int64}","page":"Docstrings","title":"Base.truncate","text":"truncate(o::Operator, max_lenght::Int; keepnorm::Bool = false)\n\nRemove all terms of length > maxlenght. Keep all terms of length <= maxlenght. i.e remove all M-local terms with M>max_lenght\n\nExample\n\nA = Operator(4)\nA += \"X\",1,\"X\",2\nA += \"Z\",1,\"Z\",2,\"Z\",4\n\njulia> A\n(1.0 + 0.0im) ZZ1Z\n(1.0 + 0.0im) XX11\n\njulia> ps.truncate(A,2)\n(1.0 + 0.0im) XX11\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.k_local_part-Tuple{AbstractOperator, Int64}","page":"Docstrings","title":"PauliStrings.k_local_part","text":"k_local_part(o::Operator, k::Int; atmost=false)\n\nReturn the k-local part of o. I.e all the strings of lenght k. Set atmost=true to return the 'at most' k-local part, i.e all the strings of length <= k.\n\nExample\n\nA = Operator(4)\nA += \"X\",1,\"X\",2\nA += \"Z\",1,\"Z\",2,\"Z\",4\nA += \"1X11\"\n\njulia> A\n(1.0 + 0.0im) ZZ1Z\n(1.0 + 0.0im) 1X11\n(1.0 + 0.0im) XX11\n\njulia> k_local_part(A,2)\n(1.0 + 0.0im) XX11\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.trim-Tuple{AbstractOperator, Int64}","page":"Docstrings","title":"PauliStrings.trim","text":"trim(o::Operator, max_strings::Int; keepnorm::Bool = false, keep::Operator=Operator(N))\n\nKeep the first max_strings terms with largest coeficients.\n\nkeepnorm is set to true to keep the norm of o.\n\nkeep is an operator that specify a set of strings that cannot be removed\n\nExample\n\nA = Operator(4)\nA += 1,\"XXXX\"\nA += 2,\"XX11\"\nA += 3,\"XX1X\"\nA += 4,\"ZZXX\"\nB = Operator(4)\nB += 1,\"XX11\"\nB += 1,\"XX1X\"\n\njulia> trim(A,2)\n(4.0 + 0.0im) ZZXX\n(3.0 + 0.0im) XX1X\n\njulia> trim(A,2;keep=B)\n(4.0 + 0.0im) ZZXX\n(3.0 + 0.0im) XX1X\n(2.0 + 0.0im) XX11\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.prune-Tuple{AbstractOperator, Real}","page":"Docstrings","title":"PauliStrings.prune","text":" prune(o::Operator, alpha::Real; keepnorm::Bool = false)\n\nKeep terms with probability 1-exp(-alpha*abs(c)) where c is the weight of the term\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.cutoff-Tuple{AbstractOperator, Real}","page":"Docstrings","title":"PauliStrings.cutoff","text":"cutoff(o::Operator, epsilon::Real; keepnorm::Bool = false)\n\nRemove all terms with weight < epsilon\n\nExample\n\nA = Operator(4)\nA += 1,\"XXXX\"\nA += 2,\"XX11\"\nA += 3,\"XX1X\"\nA += 4,\"ZZXX\"\n\njulia> cutoff(A, 2.5)\n(3.0 + 0.0im) XX1X\n(4.0 + 0.0im) ZZXX\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.rk4-Tuple{AbstractOperator, AbstractOperator, Real}","page":"Docstrings","title":"PauliStrings.rk4","text":"rk4(H::AbstractOperator, O::AbstractOperator, dt::Real; hbar::Real=1, heisenberg=true, M=2^20, keep::Operator=Operator(0))\n\nSingle step of Runge–Kutta-4 with time independant Hamiltonian. Returns O(t+dt). Set heisenberg=true for evolving an observable in the heisenberg picture. If heisenberg=false then it is assumed that O is a density matrix. M is the number of strings to keep.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.rk4-Tuple{Function, AbstractOperator, Real, Real}","page":"Docstrings","title":"PauliStrings.rk4","text":"rk4(H::Function, O::AbstractOperator, dt::Real, t::Real; hbar::Real=1, heisenberg=true, M=2^20, keep::Operator=Operator(0))\n\nSingle step of Runge–Kutta-4 with time dependant Hamiltonian. Returns O(t+dt). H is a function that takes a number (time) and returns an operator. Set heisenberg=true for evolving an observable in the heisenberg picture. If heisenberg=false then it is assumed that O is a density matrix. M is the number of strings to keep.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.rk4_lindblad-Tuple{AbstractOperator, AbstractOperator, Real, Any}","page":"Docstrings","title":"PauliStrings.rk4_lindblad","text":"rk4_lindblad(H::AbstractOperator, O::AbstractOperator, dt::Real, L; hbar::Real=1, heisenberg=true, M=2^20, keep::Operator=Operator(0), gamma=[])\n\nSingle step of Runge–Kutta-4 for solving the Lindblad equation\n\ndotO=iHO+sum_i gamma_i left(L_i^dagger O L_i -frac12  L_i^dagger L_i O right)\n\nReturns O(t+dt). L is a list of jump operators. Set heisenberg=true for evolving an observable in the heisenberg picture. If heisenberg=false then it is assumed that O is a density matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.lanczos-Tuple{AbstractOperator, AbstractOperator, Int64, Int64}","page":"Docstrings","title":"PauliStrings.lanczos","text":"lanczos(H::Operator, O::Operator, steps::Int, nterms::Int; keepnorm=true, maxlength=1000, returnOn=false)\n\nCompute the first steps lanczos coeficients for Hamiltonian H and initial operator O\n\nAt every step, the operator is trimed with trim and only nterms are kept.\n\nUsing maxlength speeds up the commutator by only keeping terms of length <= maxlength\n\nSet returnOn=true to save the On's at each step. Then the function returns a pair of lists (bn, On). The first operators of the list On is O\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:+-Union{Tuple{O}, Tuple{O, O}} where O<:AbstractOperator","page":"Docstrings","title":"Base.:+","text":"Base.:+(o1::O, o2::O) where {O<:AbstractOperator}\nBase.:+(o::AbstractOperator, a::Number)\nBase.:+(a::Number, o::AbstractOperator)\n\nAdd two operators together or add a number to an operator\n\nExample\n\nA = Operator(4)\nA += \"XYZ1\"\nA += 1, \"Y\", 4\nB = Operator(4)\nB += 2, \"Y\", 2, \"Y\", 4\nB += 1, \"Z\", 3\n\njulia> A\n(1.0 - 0.0im) 111Y\n(1.0 - 0.0im) XYZ1\n\njulia> B\n(1.0 + 0.0im) 11Z1\n(2.0 - 0.0im) 1Y1Y\n\njulia> A+B\n(1.0 + 0.0im) 11Z1\n(2.0 - 0.0im) 1Y1Y\n(1.0 - 0.0im) 111Y\n(1.0 - 0.0im) XYZ1\n\njulia> A+5\n(1.0 - 0.0im) 111Y\n(1.0 - 0.0im) XYZ1\n(5.0 + 0.0im) 1111\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:--Union{Tuple{O}, Tuple{O, O}} where O<:AbstractOperator","page":"Docstrings","title":"Base.:-","text":"Base.:-(o1::O, o2::O) where {O<:AbstractOperator}\nBase.:-(o::AbstractOperator)\nBase.:-(o::AbstractOperator, a::Number)\nBase.:-(a::Number, o::AbstractOperator)\nBase.:-(o1::Operator, o2::Operator)\n\nSubtraction between operators and numbers\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:*-Tuple{Operator, Operator}","page":"Docstrings","title":"Base.:*","text":"Base.:*(o1::Operator, o2::Operator; kwargs...)\nBase.:*(o::Operator, a::Number)\nBase.:*(a::Number, o::AbstractOperator)\n\nMultiply two operators together or an operator with a number\n\nExample\n\nA = Operator(4)\nA += \"XYZ1\"\nA += 1, \"Y\", 4\nB = Operator(4)\nB += 2, \"Y\", 2, \"Y\", 4\nB += 1, \"Z\", 3\n\njulia> A\n(1.0 - 0.0im) 111Y\n(1.0 - 0.0im) XYZ1\n\n\njulia> B\n(1.0 + 0.0im) 11Z1\n(2.0 - 0.0im) 1Y1Y\n\njulia> A*B\n(2.0 - 0.0im) X1ZY\n(1.0 - 0.0im) 11ZY\n(2.0 - 0.0im) 1Y11\n(1.0 - 0.0im) XY11\n\njulia> A*5\n(5.0 - 0.0im) 111Y\n(5.0 - 0.0im) XYZ1\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:^-Tuple{Operator, Int64}","page":"Docstrings","title":"Base.:^","text":"Base.:^(o::Operator, k::Int)\n\nkth power of o.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.commutator-Tuple{Operator, Operator}","page":"Docstrings","title":"PauliStrings.commutator","text":"commutator(o1::Operator, o2::Operator; kwargs...)\n\nCommutator of two operators. This is faster than doing o1*o2 - o2*o1.\n\nExample\n\njulia> A = Operator(4)\njulia> A += \"X111\"\njulia> B = Operator(4)\njulia> B += \"Z111\"\njulia> B += \"XYZ1\"\njulia> commutator(A,B)\n(0.0 - 2.0im) Y111\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.anticommutator-Tuple{Operator, Operator}","page":"Docstrings","title":"PauliStrings.anticommutator","text":"anticommutator(o1::Operator, o2::Operator; kwargs...)\n\nCommutator of two operators. This is faster than doing o1*o2 + o2*o1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:/-Tuple{AbstractOperator, Number}","page":"Docstrings","title":"Base.:/","text":"Base.:/(o::AbstractOperator, a::Number)\n\nDivide an operator by a number\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.compress-Tuple{AbstractOperator}","page":"Docstrings","title":"PauliStrings.compress","text":"compress(o::AbstractOperator)\n\nAccumulate repeated terms\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.trace-Tuple{Operator}","page":"Docstrings","title":"PauliStrings.trace","text":"trace(o::Operator; normalize=false)\ntrace(o::OperatorTS)\n\nTrace of an operator. If normalize is true, return the trace divided by 2^N.\n\nExample\n\njulia> A = Operator(4)\njulia> A += 2,\"1111\"\njulia> A += 3,\"XYZ1\"\njulia> trace(A)\n32.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#LinearAlgebra.diag-Tuple{AbstractOperator}","page":"Docstrings","title":"LinearAlgebra.diag","text":"LinearAlgebra.diag(o::AbstractOperator)\n\nDiagonal of an operator. Keep the strings that only contain 1's or Z's. Return another operator.\n\nExample\n\njulia> A = Operator(4)\njulia> A += 2,\"1111\"\njulia> A += 3,\"XYZ1\"\njulia> A += 3,\"Z11Z\"\njulia> diag(A)\n(2.0 + 0.0im) 1111\n(3.0 + 0.0im) Z11Z\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#LinearAlgebra.norm-Tuple{AbstractOperator}","page":"Docstrings","title":"LinearAlgebra.norm","text":"LinearAlgebra.norm(o::AbstractOperator; normalize=false)\n\nFrobenius norm, equivalent to sqrt(trace(o' * o)). If normalize is true, divide by sqrt(2^N).\n\nExample\n\njulia> A = Operator(4)\njulia> A += 2,\"X\",2\njulia> A += 1,\"Z\",1,\"Z\",3\njulia> norm(A)\n8.94427190999916\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.adjoint-Tuple{AbstractOperator}","page":"Docstrings","title":"Base.adjoint","text":"Base.adjoint(o::AbstractOperator)\n\nConjugate transpose. ' also works.\n\nExample\n\nA = Operator(3)\nA += 1im,\"X\",2\nA += 1,\"Z\",1,\"Z\",3\n\njulia> A\n\n(1.0 + 0.0im) Z1Z\n(0.0 + 1.0im) 1X1\n\n\njulia> adjoint(A)\n(1.0 - 0.0im) Z1Z\n(0.0 - 1.0im) 1X1\n\njulia> A'\n(1.0 - 0.0im) Z1Z\n(0.0 - 1.0im) 1X1\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.ptrace-Tuple{AbstractOperator, Vector{Int64}}","page":"Docstrings","title":"PauliStrings.ptrace","text":"ptrace(o::AbstractOperator, keep::Vector{Int})\n\nPartial trace.\n\nkeep is list of qubits indices to keep starting at 1 note that this still returns an operator of size N and doesnt permute the qubits this only gets rid of Pauli strings that have no support on keep and add their coeficient*2^N to the identity string\n\nExample\n\nA = Operator(5)\nA += \"XY1XZ\"\nA += \"XY11Z\"\n\njulia> ptrace(A, [3,4])\n(1.0 - 0.0im) XY1XZ\n(8.0 - 0.0im) 11111\n\njulia> ptrace(A, [1,5])\n(1.0 - 0.0im) XY1XZ\n(1.0 - 0.0im) XY11Z\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:^-Tuple{AbstractOperator, Int64}","page":"Docstrings","title":"Base.:^","text":"Base.:^(o::Operator, k::Int)\n\nkth power of o.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.trace_product-Tuple{Operator, Operator}","page":"Docstrings","title":"PauliStrings.trace_product","text":"trace_product(o1::Operator, o2::Operator; scale=0)\ntrace_product(o1::OperatorTS, o2::OperatorTS; scale=0)\n\nEfficiently compute trace(o1*o2). This is much faster than doing trace(o1*o2). If scale is not 0, then the result is normalized such that trace(identity)=scale.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.trace_product-Tuple{AbstractOperator, Int64, AbstractOperator, Int64}","page":"Docstrings","title":"PauliStrings.trace_product","text":"trace_product(A::Operator, k::Int, B::Operator, l::Int; scale=0)\n\nEfficiently compute trace(A^k*B^l). This is much faster than doing trace(A^k*B^l).\n\nIf scale is not 0, then the result is normalized such that trace(identity)=scale.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.trace_product-Tuple{AbstractOperator, Int64}","page":"Docstrings","title":"PauliStrings.trace_product","text":"trace_product(A::AbstractOperator, k::Int; scale=0)\n\nEfficiently compute trace(A^k). This is much faster than doing trace(A^k).\n\nIf scale is not 0, then the result is normalized such that trace(identity)=scale.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.trace_product_z-Tuple{AbstractOperator, AbstractOperator}","page":"Docstrings","title":"PauliStrings.trace_product_z","text":"trace_product_z(o1::AbstractOperator, o2::AbstractOperator; scale=0)\n\nEfficiently compute <0|o1*o2|0>. If scale is not 0, then the result is normalized such that trace(identity) = scale.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.moments-Tuple{AbstractOperator, Int64}","page":"Docstrings","title":"PauliStrings.moments","text":"moments(H::AbstractOperator, kmax::Int; start=1, scale=0)\n\nCompute the first kmax moments of H. start is the first moment to start from.\n\nIf scale is not 0, then the result is normalized such that trace(identity)=scale.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.rand_local1-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.rand_local1","text":"rand_local1(N::Int)\n\nRandom 1-local operator\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.rand_local2-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.rand_local2","text":"rand_local2(N::Int)\n\nRandom 2-local operator\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.rand_local1_TS1D-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.rand_local1_TS1D","text":"rand_local1_TS1D(N::Int)\n\nRandom 1-local OperatorTS in one dimension\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.rand_local2_TS1D-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.rand_local2_TS1D","text":"rand_local2_TS1D(N::Int)\n\nRandom 2-local OperatorTS in one dimension\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:+-Tuple{Operator, Tuple{Number, Vararg{Any}}}","page":"Docstrings","title":"Base.:+","text":"Base.:+(o::Operator, args::Tuple{Number, Vararg{Any}})\nBase.:+(o::Operator, args::Tuple{Vararg{Any}})\nBase.:+(o::Operator, term::Tuple{Number, String})\nBase.:+(o::Operator, term::String)\n\nMain functions to contruct spin operators. Identical signatures are available for -.\n\nExamples\n\nk-local terms can be added by adding a tuple to the operator. The first element of the tuple is an optional coefficient. The other element are couples (symbol,site) where symbol can be \"X\", \"Y\", \"Z\", \"Sx\", \"Sy\", \"Sz\", \"S+\", \"S-\" and site is an integer specifying the site on wich the symbol is acting.\n\nA = Operator(4)\nA += 2, \"X\",1,\"X\",2\nA += 3, \"Y\",1,\"X\",2\nA += \"X\",3,\"X\",4\nA += 4,\"Z\",3\nA += 5.2,\"X\",1,\"Y\",2,\"Z\",3\n\njulia> A\n(4.0 + 0.0im) 11Z1\n(3.0 - 0.0im) YX11\n(1.0 + 0.0im) 11XX\n(2.0 + 0.0im) XX11\n(5.2 - 0.0im) XYZ1\n\nFull strings can also be added:\n\nA = Operator(4)\nA += 2, \"1XXY\"\nA += 2im, \"11Z1\"\n\njulia> A\n(0.0 + 2.0im) 11Z1\n(2.0 - 0.0im) 1XXY\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.all_strings-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.all_strings","text":"all_strings(N::Int)\n\nReturn the sum of all the strings supported on N spins, with coeficients 1\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.all_k_local-Tuple{Int64, Int64}","page":"Docstrings","title":"PauliStrings.all_k_local","text":"all_k_local(N::Int, k::Int; atmost=false)\n\nReturn the sum of all the k-local strings supported on N spins, with coeficients 1. These are k-local only strings, not including strings shorter than k.\n\nExample\n\njulia> all_k_local(2, 1)\n(1.0 + 0.0im) X1\n(1.0 + 0.0im) 1X\n(1.0 + 0.0im) Z1\n(1.0 - 0.0im) Y1\n(1.0 + 0.0im) 1Z\n(1.0 - 0.0im) 1Y\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.all_x-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.all_x","text":"all_x(N::Int)\n\nReturn the sum of all the strings supported on N spins with only x and with coeficients 1\n\nExample\n\njulia> all_x(2)\n(1.0 + 0.0im) 11\n(1.0 + 0.0im) X1\n(1.0 + 0.0im) 1X\n(1.0 + 0.0im) XX\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.all_y-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.all_y","text":"all_y(N::Int)\n\nReturn the sum of all the strings supported on N spins with only y and with coeficients 1\n\nExample\n\njulia> all_y(2)\n(1.0 + 0.0im) 11\n(1.0 - 0.0im) Y1\n(1.0 - 0.0im) 1Y\n(1.0 - 0.0im) YY\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.all_z-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.all_z","text":"all_z(N::Int)\n\nReturn the sum of all the strings supported on N spins with only z and with coeficients 1\n\nExample\n\njulia> all_z(2)\n(1.0 + 0.0im) 11\n(1.0 + 0.0im) Z1\n(1.0 + 0.0im) 1Z\n(1.0 + 0.0im) ZZ\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.majorana-Tuple{Int64, Int64}","page":"Docstrings","title":"PauliStrings.majorana","text":"majorana(N::Int, k::Int)\n\nReturn the k-th Majorana operator on N spins. There are 2N Majoranas supported on N spins. They all anticomute :\n\ngamma_i gamma_j = 2delta_ij\n\nExample\n\njulia> majorana(4,1)\n(1.0 + 0.0im) X111\n\njulia> majorana(4,2)\n(1.0 - 0.0im) Y111\n\njulia> majorana(4,3)\n(1.0 + 0.0im) ZX11\n\njulia> majorana(4,4)\n(1.0 - 0.0im) ZY11\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.string_2d-Tuple{Tuple, Int64, Int64}","page":"Docstrings","title":"PauliStrings.string_2d","text":"string_2d(args::Tuple{Vararg{Any}}, L1::Int, L2::Int; pbc=false)\n\nHelper functions to construct 2d pauli strings. The tuple is composed of triplets the form (P,x,y,...) where P is one of \"X\", \"Y\", \"Z\", \"Sx\", \"Sy\", \"Sz\", \"S-\", \"S+\", and x, y label the position in the lattice. If pbc = true, the x and y coordinates will always be brough back to the range 1 L_1 and 1 L_2 respectively.\n\nExample:\n\nL1 = L2 = 2\nA = Operator(L1 * L2)\nA += 0.5 * string_2d((\"Z\", 1, 1, \"Z\", 2, 1), L1, L2) # Horizontal interaction\nA += 1.0 * string_2d((\"Z\", 1, 1, \"Z\", 1, 2), L1, L2) # Vertical interaction\n\njulia> A\n(1.0 + 0.0im) Z1Z1\n(0.5 + 0.0im) ZZ11\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.PauliStringTS-Union{Tuple{PauliString}, Tuple{Ls}} where Ls","page":"Docstrings","title":"PauliStrings.PauliStringTS","text":"PauliStringTS{Ls}(p::PauliString)\n\nConstruct a translation symmetric sum of a Pauli string p. Ls is a tuple that specifies the periodicity in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.OperatorTS-Union{Tuple{Operator}, Tuple{Ls}} where Ls","page":"Docstrings","title":"PauliStrings.OperatorTS","text":"OperatorTS{Ls}(o::Operator)\n\nConstruct an n-dimensional translation symmetric operator from o where Ls is a tuple of integers (L1, L2, ...) The resulting operator is equivalent to\n\nO_mathrmTS = sum_T T^dag O T\n\nwhere T are all translations on the L1×L2×… hypercube. So if you feed it an operator that is already a sum, you should afterwards normalize it by the number of sites.\n\nTo get a dense operator from this lazy sum representation, see resum. To get a single term, see representative.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.OperatorTS1D-Tuple{Integer}","page":"Docstrings","title":"PauliStrings.OperatorTS1D","text":"OperatorTS1D(N::Integer)\n\nInitialize a zero 1D translation-invariant operator on N qubits.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.OperatorTS1D-Tuple{Operator}","page":"Docstrings","title":"PauliStrings.OperatorTS1D","text":"OperatorTS1D(o::Operator; full=true)\n\nInitialize a 1D translation invariant operator from an Operator O=sum_i o_i O_i where O_i=T_i(O_0) and T_i is the i-sites translation operator. Set full=true if passing O, an Operator that is supported on the whole chain (i.e converting from a translation symmetric Operator) Set full=false if passing O_0,a local term o such that the full operator is O=sum_i o_i T_i(O_0)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.representative-Tuple{OperatorTS}","page":"Docstrings","title":"PauliStrings.representative","text":"representative(o::OperatorTS)\n\nReturns a unique term of the symmetric sum represented by o.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.representative-Tuple{PauliStringTS}","page":"Docstrings","title":"PauliStrings.representative","text":"representative(p::PauliStringTS)\n\nReturns a unique representative string of the translation symmetric sum of the Pauli string p.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.resum-Tuple{OperatorTS}","page":"Docstrings","title":"PauliStrings.resum","text":"resum(o::OperatorTS)\n\nPerform the symmetric sum represented by o to yield a dense Operator containing unsymmetrized PauliStrings.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.is_ts-Tuple{Operator}","page":"Docstrings","title":"PauliStrings.is_ts","text":"is_ts(o::Operator)\n\nreturn true if o is translation symmetric in one dimension\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.is_ts-Tuple{Operator, Tuple}","page":"Docstrings","title":"PauliStrings.is_ts","text":"is_ts(o::Operator, Ls::Tuple)\n\nreturn true if o is translation symmetric on a hypercube with side lengths Ls.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.is_ts2d-Tuple{Operator, Any}","page":"Docstrings","title":"PauliStrings.is_ts2d","text":"is_ts2d(o::Operator, L1)\n\nreturn true if o is translation symmetric on a rectangle with sidelengths L1 × qubitlength(o)÷L1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.trace_zpart-Tuple{Operator}","page":"Docstrings","title":"PauliStrings.trace_zpart","text":"trace_zpart(o::Operator)\n\nComputes <0|o|0>.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.expect-Tuple{Operator, String}","page":"Docstrings","title":"PauliStrings.expect","text":"expect(o::Operator, state::String)\n\nComputes the expectation value <state|o|state>. State is a single binary string that represents a pure state in the computational basis.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.expect-Tuple{Operator, String, String}","page":"Docstrings","title":"PauliStrings.expect","text":"expect(o::Operator, in_state::String, out_state::String)\n\nComputes the expectation value <out_state|o|in_state>. in_state and out_state are single binary strings that represents pure states in the computational basis.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.expect_product-Tuple{Operator, Operator, String}","page":"Docstrings","title":"PauliStrings.expect_product","text":"expect_product(o1::Operator, o2::Operator, state::String)\n\nComputes the expectation value <state|o1*o2|state>. State is a single binary string that represents a pure state in the computational basis.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.Circuit-Tuple{Int64}","page":"Docstrings","title":"PauliStrings.Circuits.Circuit","text":"Circuit(N::Int; max_strings=2^30, noise_amplitude=0)\n\nCreates an empty quantum circuit with N qubits. max_strings is the maximum number of strings to keep in the operator. noise_amplitude is the amplitude of the noise gate.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.push!-Tuple{Circuit, String, Vararg{Real}}","page":"Docstrings","title":"Base.push!","text":"push!(c::Circuit, gate::String, sites::Real...)\n\nAdds a gate to the circuit c. The gate is specified by a string gate and a list of sites sites. The gates have the same naming convention as in Qiskit. Allowed gates are: \"X\", \"Y\", \"Z\", \"H\", \"S\", \"T\", \"Tdg\", \"Phase\", \"CNOT\", \"Swap\", \"CX\", \"CY\", \"CZ\", \"CCX\", \"CSX\", \"CSXdg\", \"MCZ\", \"Noise\".\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.pushfirst!-Tuple{Circuit, String, Vararg{Real}}","page":"Docstrings","title":"Base.pushfirst!","text":"pushfirst!(c::Circuit, gate::String, sites::Real...)\n\nAdds a gate to the beginning of the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.XGate-Tuple{Int64, Int64}","page":"Docstrings","title":"PauliStrings.Circuits.XGate","text":"XGate(N::Int, i::Int)\nYGate(N::Int, i::Int)\nZGate(N::Int, i::Int)\nHGate(N::Int, i::Int)\nSGate(N::Int, i::Int)\nTGate(N::Int, i::Int)\nTdgGate(N::Int, i::Int)\nSXGate(N::Int, i::Int)\n\nCreates a single qubit gate acting on qubit i of a N qubit system.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.UGate-Tuple{Int64, Int64, Real, Real, Real}","page":"Docstrings","title":"PauliStrings.Circuits.UGate","text":"UGate(N::Int, i::Int, theta::Real, phi::Real, lam::Real)\n\nGeneral 1-qubit rotation of qubit i of a N qubit system with Euler angles theta, phi, lam of form\n\nU(theta phi lambda) =beginpmatrixcosleft(theta2right)  -e^ilambdasinleft(theta2right) e^iphisinleft(theta2right)  e^i(phi+lambda)cosleft(theta2right)endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.RXGate-Tuple{Int64, Int64, Real}","page":"Docstrings","title":"PauliStrings.Circuits.RXGate","text":"RXGate(N::Int, i::Int, phi::Real)\nRYGate(N::Int, i::Int, theta::Real)\nRZGate(N::Int, i::Int, phi::Real)\n\n1-qubit rotation of qubit i of a N qubit system around specific axis.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.PhaseGate-Tuple{Int64, Int64, Real}","page":"Docstrings","title":"PauliStrings.Circuits.PhaseGate","text":"PhaseGate(N::Int, i::Int, theta::Real)\n\nCreates a phase gate acting on qubit i of a N qubit system with phase theta.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.CPhaseGate-Tuple{Int64, Int64, Int64, Real}","page":"Docstrings","title":"PauliStrings.Circuits.CPhaseGate","text":"CPhaseGate(N::Int, i::Int, j::Int, theta::Real)\n\nControled phase gate with control qubit i and target qubit j of a N qubit system.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.CXGate-Tuple{Int64, Int64, Int64}","page":"Docstrings","title":"PauliStrings.Circuits.CXGate","text":"CXGate(N::Int, i::Int, j::Int)\nCYGate(N::Int, i::Int, j::Int)\nCZGate(N::Int, i::Int, j::Int)\nCNOTGate(N::Int, i::Int, j::Int)\n\nCreates a two qubit gate with control qubit i and target qubit j of a N qubit system.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.SwapGate-Tuple{Int64, Int64, Int64}","page":"Docstrings","title":"PauliStrings.Circuits.SwapGate","text":"SwapGate(N::Int, i::Int, j::Int)\n\nCreates a swap gate between qubits i and j of a N qubit system.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.CSXGate-Tuple{Int64, Int64, Int64}","page":"Docstrings","title":"PauliStrings.Circuits.CSXGate","text":"CSXGate(N::Int, i::Int, j::Int)\nCSXdgGate(N::Int, i::Int, j::Int)\n\nControlled sqrt X gate and its dagger\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.CCXGate-NTuple{4, Int64}","page":"Docstrings","title":"PauliStrings.Circuits.CCXGate","text":"CCXGate(N::Int, i::Int, j::Int, k::Int)\n\nTofolli gate with control qubits i and j and target qubit k of a N qubit system.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.MCZGate-Tuple{Int64, Vararg{Int64}}","page":"Docstrings","title":"PauliStrings.Circuits.MCZGate","text":"MCZGate(N::Int, sites::Int...)\n\nCreates a multi-controlled Z gate acting on sites qubits of a N qubit system.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.XXPlusYYGate-Tuple{Int64, Int64, Int64, Real, Real}","page":"Docstrings","title":"PauliStrings.Circuits.XXPlusYYGate","text":"XXPlusYYGate(N::Int, i::Int, j::Int, theta::Real, beta::Real)\n\nXX+YY gate between qubits i and j of a N qubit system.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.grover_diffusion-Tuple{Int64, Vararg{Int64}}","page":"Docstrings","title":"PauliStrings.Circuits.grover_diffusion","text":"grover_diffusion(N::Int, sites::Int...)\n\nCreates the Grover diffusion operator acting on sites qubits of a N qubit system.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.Circuits.compile-Tuple{Circuit}","page":"Docstrings","title":"PauliStrings.Circuits.compile","text":"compile(c::Circuit)\n\nCompiles the quantum circuit c into a unitary operator. Applies the gates in the order they were added. Applies noise gates if present and trim the operator to c.max_strings strings at each step.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.expect-Tuple{Circuit, String}","page":"Docstrings","title":"PauliStrings.expect","text":"expect(c::Circuit, state::String)\n\nComputes the expectation value <state|c|0>. State is a single binary string that represents a pure state in the computational basis.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.expect-Tuple{Circuit, String, String}","page":"Docstrings","title":"PauliStrings.expect","text":"expect(c::Circuit, in_state::String, out_state::String)\n\nComputes the expectation value of the state out_state after applying the circuit c to the state in_state.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.op_to_strings-Tuple{Operator}","page":"Docstrings","title":"PauliStrings.op_to_strings","text":"op_to_strings(o::Operator)\n\ntakes an operator, return (coefs, strings) where coefs is a list of numbers and strings is a list of pauli string coefs[i] multiply strings[i]\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.get_coeffs-Tuple{AbstractOperator}","page":"Docstrings","title":"PauliStrings.get_coeffs","text":"get_coeffs(o::AbstractOperator)\n\nReturn the list of coefficient in front of each strings.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.set_coeffs-Union{Tuple{T}, Tuple{AbstractOperator, Vector{T}}} where T<:Number","page":"Docstrings","title":"PauliStrings.set_coeffs","text":"set_coeffs(o::Operator, coefs::Vector{T}) where T <: Number\n\nSets the coefficient of o to coefs. Inplace.\n\nA = Operator(4)\nA += 2, \"1XXY\"\nA += 3, \"11Z1\"\n\njulia> A\n(3.0 + 0.0im) 11Z1\n(2.0 - 0.0im) 1XXY\njulia> set_coeffs(A, [5,6])\njulia> A\n(5.0 + 0.0im) 11Z1\n(6.0 - 0.0im) 1XXY\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.Matrix-Tuple{Operator}","page":"Docstrings","title":"Base.Matrix","text":"Matrix(o::Operator)\n\nConvert an operator to a dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#SparseArrays.sparse-Tuple{PauliString}","page":"Docstrings","title":"SparseArrays.sparse","text":"SparseArrays.sparse(pauli::PauliString)\n\nConvert a PauliString to a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#SparseArrays.sparse-Tuple{Operator}","page":"Docstrings","title":"SparseArrays.sparse","text":"SparseArrays.sparse(o::Operator)\n\nConvert an operator to a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.get_coeff-Union{Tuple{P}, Tuple{Operator{P}, P}} where P","page":"Docstrings","title":"PauliStrings.get_coeff","text":"get_coeff(o::Operator{P}, p::P) where {P}\n\nReturn the coefficient of the string p in o.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.get_pauli-Tuple{Operator, Int64}","page":"Docstrings","title":"PauliStrings.get_pauli","text":"get_pauli(o::Operator, i::Int)\n\nReturn an operator that represent the i-th pauli string of `o'. Does not return the string multiplied by the coefficient. Only the string.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.string-Tuple{PauliString}","page":"Docstrings","title":"Base.string","text":"Base.string(x::PauliString)\n\nConvert a PauliString to its string representation.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.compress-Tuple{Operator}","page":"Docstrings","title":"PauliStrings.compress","text":"compress(o::AbstractOperator)\n\nAccumulate repeated terms\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.xcount-Tuple{PauliString}","page":"Docstrings","title":"PauliStrings.xcount","text":"xcount(p::PauliString)\n\nCount the number of X operators in a string.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.ycount-Tuple{PauliString}","page":"Docstrings","title":"PauliStrings.ycount","text":"ycount(p::PauliString)\n\nCount the number of Y operators in a string.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.zcount-Tuple{PauliString}","page":"Docstrings","title":"PauliStrings.zcount","text":"zcount(p::PauliString)\n\nCount the number of Z operators in a string.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PauliStrings.pauli_weight-Tuple{PauliString}","page":"Docstrings","title":"PauliStrings.pauli_weight","text":"pauli_weight(p::PauliString)\n\nCount the number of non unit operators in a string.\n\n\n\n\n\n","category":"method"}]
}
