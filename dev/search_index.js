var documenterSearchIndex = {"docs":
[{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/#Basics","page":"Documentation","title":"Basics","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Operator(N::Int)","category":"page"},{"location":"documentation/#PauliStrings.Operator-Tuple{Int64}","page":"Documentation","title":"PauliStrings.Operator","text":"Operator(N::Int)\n\nInitialize an empty operator on N qubits\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Operator(o::OperatorTS1D)","category":"page"},{"location":"documentation/#PauliStrings.Operator-Tuple{OperatorTS1D}","page":"Documentation","title":"PauliStrings.Operator","text":"Operator(o::OperatorTS1D)\n\nConvert an OperatorTS1D to an Operator\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"OperatorTS1D(o::Operator; full=true)","category":"page"},{"location":"documentation/#PauliStrings.OperatorTS1D-Tuple{Operator}","page":"Documentation","title":"PauliStrings.OperatorTS1D","text":"OperatorTS1D(o::Operator; full=true)\n\nInitialize a 1D translation invariant operator from an Operator O=sum_i o_i O_i where O_i=T_i(O_0) and T_i is the i-sites translation operator.\nSet full=true if passing O, an Operator that is supported on the whole chain (i.e converting from a translation symmetric Operator)\nSet full=false if passing O_0,a local term o such that the full operator is O=sum_i o_i T_i(O_0)\n\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Base.length(o::Operator)","category":"page"},{"location":"documentation/#Base.length-Tuple{Operator}","page":"Documentation","title":"Base.length","text":"Base.length(o::Operator)\nBase.length(o::OperatorTS1D)\n\nNumber of pauli strings in an operator\n\nExample\n\njulia> A = Operator(4)\njulia> A += \"X111\"\njulia> A += \"XYZ1\"\njulia> A += 2, \"Y\", 4\njulia> length(A)\n3\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"eye(N::Int)","category":"page"},{"location":"documentation/#PauliStrings.eye-Tuple{Int64}","page":"Documentation","title":"PauliStrings.eye","text":"eye(N::Int)\n\nIdentity operator on N qubits\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Base.:+(o::Operator, args::Tuple{Number, Vararg{Any}})\nBase.:+(o::Operator, args::Tuple{Vararg{Any}})\nBase.:+(o::Operator, term::Tuple{Number, String})\nBase.:+(o::Operator, term::String)","category":"page"},{"location":"documentation/#Base.:+-Tuple{Operator, Tuple{Number, Vararg{Any, N} where N}}","page":"Documentation","title":"Base.:+","text":"Base.:+(o::Operator, args::Tuple{Number, Vararg{Any}})\nBase.:+(o::Operator, args::Tuple{Vararg{Any}})\nBase.:+(o::Operator, term::Tuple{Number, String})\nBase.:+(o::Operator, term::String)\n\nMain functions to contruct spin operators. Identical signatures are available for -.\n\nExamples\n\nk-local terms can be added by adding a tuple to the operator. The first element of the tuple is an optional coeficient. The other element are couples (symbol,site) where symbol can be \"X\", \"Y\", \"Z\", \"Sx\", \"Sy\", \"Sz\", \"S+\", \"S-\" and site is an integer specifying the site on wich the symbol is acting.\n\nA = Operator(4)\nA += 2, \"X\",1,\"X\",2\nA += 3, \"Y\",1,\"X\",2\nA += \"X\",3,\"X\",4\nA += 4,\"Z\",3\nA += 5.2,\"X\",1,\"Y\",2,\"Z\",3\n\njulia> A\n(4.0 + 0.0im) 11Z1\n(3.0 - 0.0im) YX11\n(1.0 + 0.0im) 11XX\n(2.0 + 0.0im) XX11\n(5.2 - 0.0im) XYZ1\n\nFull strings can also be added:\n\nA = Operator(4)\nA += 2, \"1XXY\"\nA += 2im, \"11Z1\"\n\njulia> A\n(0.0 + 2.0im) 11Z1\n(2.0 - 0.0im) 1XXY\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:+-Tuple{Operator, Tuple}","page":"Documentation","title":"Base.:+","text":"+(x, y...)\n\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:+-Tuple{Operator, Tuple{Number, String}}","page":"Documentation","title":"Base.:+","text":"+(x, y...)\n\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\n\n\n\n\nBase.:+(o::Operator, args::Tuple{Number, Vararg{Any}})\nBase.:+(o::Operator, args::Tuple{Vararg{Any}})\nBase.:+(o::Operator, term::Tuple{Number, String})\nBase.:+(o::Operator, term::String)\n\nMain functions to contruct spin operators. Identical signatures are available for -.\n\nExamples\n\nk-local terms can be added by adding a tuple to the operator. The first element of the tuple is an optional coeficient. The other element are couples (symbol,site) where symbol can be \"X\", \"Y\", \"Z\", \"Sx\", \"Sy\", \"Sz\", \"S+\", \"S-\" and site is an integer specifying the site on wich the symbol is acting.\n\nA = Operator(4)\nA += 2, \"X\",1,\"X\",2\nA += 3, \"Y\",1,\"X\",2\nA += \"X\",3,\"X\",4\nA += 4,\"Z\",3\nA += 5.2,\"X\",1,\"Y\",2,\"Z\",3\n\njulia> A\n(4.0 + 0.0im) 11Z1\n(3.0 - 0.0im) YX11\n(1.0 + 0.0im) 11XX\n(2.0 + 0.0im) XX11\n(5.2 - 0.0im) XYZ1\n\nFull strings can also be added:\n\nA = Operator(4)\nA += 2, \"1XXY\"\nA += 2im, \"11Z1\"\n\njulia> A\n(0.0 + 2.0im) 11Z1\n(2.0 - 0.0im) 1XXY\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:+-Tuple{Operator, String}","page":"Documentation","title":"Base.:+","text":"+(x, y...)\n\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Operations","page":"Documentation","title":"Operations","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"add(o1::Operator, o2::Operator)\nBase.:+(o1::Operator, o2::Operator)\nBase.:+(o::Operator, a::Number)\nBase.:+(a::Number, o::Operator)","category":"page"},{"location":"documentation/#PauliStrings.add-Tuple{Operator, Operator}","page":"Documentation","title":"PauliStrings.add","text":"add(o1::Operator, o2::Operator)\nBase.:+(o1::Operator, o2::Operator)\nBase.:+(o::Operator, a::Number)\nBase.:+(a::Number, o::Operator)\n\nAdd two operators together or add a number to an operator\n\nExample\n\nA = Operator(4)\nA += \"XYZ1\"\nA += 1, \"Y\", 4\nB = Operator(4)\nB += 2, \"Y\", 2, \"Y\", 4\nB += 1, \"Z\", 3\n\njulia> A\n(1.0 - 0.0im) 111Y\n(1.0 - 0.0im) XYZ1\n\njulia> B\n(1.0 + 0.0im) 11Z1\n(2.0 - 0.0im) 1Y1Y\n\njulia> A+B\n(1.0 + 0.0im) 11Z1\n(2.0 - 0.0im) 1Y1Y\n(1.0 - 0.0im) 111Y\n(1.0 - 0.0im) XYZ1\n\njulia> A+5\n(1.0 - 0.0im) 111Y\n(1.0 - 0.0im) XYZ1\n(5.0 + 0.0im) 1111\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:+-Tuple{Operator, Operator}","page":"Documentation","title":"Base.:+","text":"+(x, y...)\n\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:+-Tuple{Operator, Number}","page":"Documentation","title":"Base.:+","text":"+(x, y...)\n\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:+-Tuple{Number, Operator}","page":"Documentation","title":"Base.:+","text":"+(x, y...)\n\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Base.:*(o1::Operator, o2::Operator)\nBase.:*(o::Operator, a::Number)\nBase.:*(a::Number, o::Operator)","category":"page"},{"location":"documentation/#Base.:*-Tuple{Operator, Operator}","page":"Documentation","title":"Base.:*","text":"Base.:*(o1::Operator, o2::Operator)\nBase.:*(o::Operator, a::Number)\nBase.:*(a::Number, o::Operator)\n\nMultiply two operators together or an operator with a number\n\nExample\n\nA = Operator(4)\nA += \"XYZ1\"\nA += 1, \"Y\", 4\nB = Operator(4)\nB += 2, \"Y\", 2, \"Y\", 4\nB += 1, \"Z\", 3\n\njulia> A\n(1.0 - 0.0im) 111Y\n(1.0 - 0.0im) XYZ1\n\n\njulia> B\n(1.0 + 0.0im) 11Z1\n(2.0 - 0.0im) 1Y1Y\n\njulia> A*B\n(2.0 - 0.0im) X1ZY\n(1.0 - 0.0im) 11ZY\n(2.0 - 0.0im) 1Y11\n(1.0 - 0.0im) XY11\n\njulia> A*5\n(5.0 - 0.0im) 111Y\n(5.0 - 0.0im) XYZ1\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:*-Tuple{Operator, Number}","page":"Documentation","title":"Base.:*","text":"*(x, y...)\n\nMultiplication operator. x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...).\n\nExamples\n\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:*-Tuple{Number, Operator}","page":"Documentation","title":"Base.:*","text":"*(x, y...)\n\nMultiplication operator. x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...).\n\nExamples\n\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Base.:-(o::Operator)\nBase.:-(o1::Operator, o2::Operator)\nBase.:-(o::Operator, a::Real)\nBase.:-(a::Real, o::Operator)","category":"page"},{"location":"documentation/#Base.:--Tuple{Operator}","page":"Documentation","title":"Base.:-","text":"Base.:-(o::Operator)\nBase.:-(o1::Operator, o2::Operator)\nBase.:-(o::Operator, a::Real)\nBase.:-(a::Real, o::Operator)\n\nSubtraction between operators and numbers\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:--Tuple{Operator, Operator}","page":"Documentation","title":"Base.:-","text":"-(x, y)\n\nSubtraction operator.\n\nExamples\n\njulia> 2 - 3\n-1\n\njulia> -(2, 4.5)\n-2.5\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:--Tuple{Operator, Real}","page":"Documentation","title":"Base.:-","text":"-(x, y)\n\nSubtraction operator.\n\nExamples\n\njulia> 2 - 3\n-1\n\njulia> -(2, 4.5)\n-2.5\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Base.:--Tuple{Real, Operator}","page":"Documentation","title":"Base.:-","text":"-(x, y)\n\nSubtraction operator.\n\nExamples\n\njulia> 2 - 3\n-1\n\njulia> -(2, 4.5)\n-2.5\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"com(o1::Operator, o2::Operator; epsilon::Real=0, maxlength::Int=1000)","category":"page"},{"location":"documentation/#PauliStrings.com-Tuple{Operator, Operator}","page":"Documentation","title":"PauliStrings.com","text":"com(o1::Operator, o2::Operator; epsilon::Real=0, maxlength::Int=1000)\ncom(o1::OperatorTS1D, o2::OperatorTS1D; anti=false)\n\nCommutator of two operators. Set anti=true to compute the anti-commutator.\n\nExample\n\njulia> A = Operator(4)\njulia> A += \"X111\"\njulia> B = Operator(4)\njulia> B += \"Z111\"\njulia> B += \"XYZ1\"\njulia> com(A,B)\n(0.0 - 2.0im) Y111\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"diag(o::Operator)","category":"page"},{"location":"documentation/#PauliStrings.diag-Tuple{Operator}","page":"Documentation","title":"PauliStrings.diag","text":"diag(o::Operator)\ndiag(o::OperatorTS1D)\n\nDiagonal of an operator. Keep the strings that only contain 1's or Z's. Return another operator.\n\nExample\n\njulia> A = Operator(4)\njulia> A += 2,\"1111\"\njulia> A += 3,\"XYZ1\"\njulia> A += 3,\"Z11Z\"\njulia> diag(A)\n(2.0 + 0.0im) 1111\n(3.0 + 0.0im) Z11Z\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"trace(o::Operator)","category":"page"},{"location":"documentation/#PauliStrings.trace-Tuple{Operator}","page":"Documentation","title":"PauliStrings.trace","text":"trace(o::Operator)\ntrace(o::OperatorTS1D)\n\nTrace of an operator\n\nExample\n\njulia> A = Operator(4)\njulia> A += 2,\"1111\"\njulia> A += 3,\"XYZ1\"\njulia> trace(A)\n32.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"opnorm(o::Operator)","category":"page"},{"location":"documentation/#PauliStrings.opnorm-Tuple{Operator}","page":"Documentation","title":"PauliStrings.opnorm","text":"opnorm(o::Operator)\nopnorm(o::OperatorTS1D)\n\nFrobenius norm\n\nExample\n\njulia> A = Operator(4)\njulia> A += 2,\"X\",2\njulia> A += 1,\"Z\",1,\"Z\",3\njulia> opnorm(A)\n8.94427190999916\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"dagger(o::Operator)","category":"page"},{"location":"documentation/#PauliStrings.dagger-Tuple{Operator}","page":"Documentation","title":"PauliStrings.dagger","text":"dagger(o::Operator)\ndagger(o::OperatorTS1D)\n\nConjugate transpose\n\nExample\n\nA = Operator(3)\nA += 1im,\"X\",2\nA += 1,\"Z\",1,\"Z\",3\n\njulia> A\n\n(1.0 + 0.0im) Z1Z\n(0.0 + 1.0im) 1X1\n\n\njulia> dagger(A)\n(1.0 - 0.0im) Z1Z\n(0.0 - 1.0im) 1X1\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"ptrace(o::Operator, keep::Vector{Int})","category":"page"},{"location":"documentation/#PauliStrings.ptrace-Tuple{Operator, Vector{Int64}}","page":"Documentation","title":"PauliStrings.ptrace","text":"ptrace(o::Operator, keep::Vector{Int})\n\nPartial trace.\n\nkeep is list of qubits indices to keep starting at 1 note that this still returns an operator of size N and doesnt permute the qubits this only gets rid of Pauli strings that have no support on keep and add their coeficient*2^N to the identity string\n\nExample\n\nA = Operator(5)\nA += \"XY1XZ\"\nA += \"XY11Z\"\n\njulia> ptrace(A, [3,4])\n(1.0 - 0.0im) XY1XZ\n(8.0 - 0.0im) 11111\n\njulia> ptrace(A, [1,5])\n(1.0 - 0.0im) XY1XZ\n(1.0 - 0.0im) XY11Z\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Power-and-moments","page":"Documentation","title":"Power and moments","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Base.:^(o::Operator, k::Int)","category":"page"},{"location":"documentation/#Base.:^-Tuple{Operator, Int64}","page":"Documentation","title":"Base.:^","text":"Base.:^(o::Operator, k::Int)\n\nkth power of o. Same as oppow.\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"oppow(o::Operator, k::Int)","category":"page"},{"location":"documentation/#PauliStrings.oppow-Tuple{Operator, Int64}","page":"Documentation","title":"PauliStrings.oppow","text":"oppow(o::Operator, k::Int)\noppow(o::OperatorTS1D, k::Int)\n\nkth power of o. Same as ^.\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"trace_product(o1::Operator, o2::Operator; scale=0)","category":"page"},{"location":"documentation/#PauliStrings.trace_product-Tuple{Operator, Operator}","page":"Documentation","title":"PauliStrings.trace_product","text":"trace_product(o1::Operator, o2::Operator; scale=0)\ntrace_product(o1::OperatorTS1D, o2::OperatorTS1D; scale=0)\n\nEfficiently compute trace(o1*o2). This is much faster than doing trace(o1*o2). If scale is not 0, then the result is normalized such that trace(identity)=scale.\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"trace_product(A::Operator, k::Int, B::Operator, l::Int; scale=0)","category":"page"},{"location":"documentation/#PauliStrings.trace_product-Tuple{Operator, Int64, Operator, Int64}","page":"Documentation","title":"PauliStrings.trace_product","text":"trace_product(A::Operator, k::Int, B::Operator, l::Int; scale=0)\ntrace_product(A::OperatorTS1D, k::Int, B::OperatorTS1D, l::Int; scale=0)\n\nEfficiently compute trace(A^k*B^l). This is much faster than doing trace(A^k*B^l).\n\nIf scale is not 0, then the result is normalized such that trace(identity)=scale.\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"trace_product(A::Operator, k::Int; scale=0)","category":"page"},{"location":"documentation/#PauliStrings.trace_product-Tuple{Operator, Int64}","page":"Documentation","title":"PauliStrings.trace_product","text":"trace_product(A::Operator, k::Int; scale=0)\n\nEfficiently compute trace(A^k). This is much faster than doing trace(A^k).\n\nIf scale is not 0, then the result is normalized such that trace(identity)=scale.\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"moments(H::Operator, kmax::Int; start=1, scale=0)","category":"page"},{"location":"documentation/#PauliStrings.moments-Tuple{Operator, Int64}","page":"Documentation","title":"PauliStrings.moments","text":"moments(H::Operator, kmax::Int; start=1, scale=0)\nmoments(H::OperatorTS1D, kmax::Int; start=1, scale=0)\n\nCompute the first kmax moments of H. start is the first moment to start from.\n\nIf scale is not 0, then the result is normalized such that trace(identity)=scale.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Random-operators","page":"Documentation","title":"Random operators","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"rand_local1(N::Int)","category":"page"},{"location":"documentation/#PauliStrings.rand_local1-Tuple{Int64}","page":"Documentation","title":"PauliStrings.rand_local1","text":"rand_local2(N::Int)\n\nRandom 1-local operator\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"rand_local2(N::Int)","category":"page"},{"location":"documentation/#PauliStrings.rand_local2-Tuple{Int64}","page":"Documentation","title":"PauliStrings.rand_local2","text":"rand_local2(N::Int)\n\nRandom 2-local operator\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"rand_local1_TS1D(N::Int)","category":"page"},{"location":"documentation/#PauliStrings.rand_local1_TS1D-Tuple{Int64}","page":"Documentation","title":"PauliStrings.rand_local1_TS1D","text":"rand_local1_TS1D(N::Int)\n\nRandom 1-local OperatorTS1D\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"rand_local2_TS1D(N::Int)","category":"page"},{"location":"documentation/#PauliStrings.rand_local2_TS1D-Tuple{Int64}","page":"Documentation","title":"PauliStrings.rand_local2_TS1D","text":"rand_local2_TS1D(N::Int)\n\nRandom 2-local OperatorTS1D\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Truncation-and-noise","page":"Documentation","title":"Truncation and noise","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"truncate(o::Operator, N::Int; keepnorm::Bool = false)","category":"page"},{"location":"documentation/#Base.truncate-Tuple{Operator, Int64}","page":"Documentation","title":"Base.truncate","text":"truncate(o::Operator, N::Int; keepnorm::Bool = false)\n\nRemove all terms of length > N. Keep all terms of length <= N. i.e remove all M-local terms with M>N\n\nExample\n\nA = Operator(4)\nA += \"X\",1,\"X\",2\nA += \"Z\",1,\"Z\",2,\"Z\",4\n\njulia> A\n(1.0 + 0.0im) ZZ1Z\n(1.0 + 0.0im) XX11\n\njulia> ps.truncate(A,2)\n(1.0 + 0.0im) XX11\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"trim(o::Operator, N::Int; keepnorm::Bool = false, keep::Operator=Operator(N))","category":"page"},{"location":"documentation/#PauliStrings.trim-Tuple{Operator, Int64}","page":"Documentation","title":"PauliStrings.trim","text":"trim(o::Operator, N::Int; keepnorm::Bool = false, keep::Operator=Operator(N))\n\nKeep the first N terms with largest coeficients.\n\nkeepnorm is set to true to keep the norm of o.\n\nkeep is an operator that specify a set of strings that cannot be removed\n\nExample\n\nA = Operator(4)\nA += 1,\"XXXX\"\nA += 2,\"XX11\"\nA += 3,\"XX1X\"\nA += 4,\"ZZXX\"\nB = Operator(4)\nB += 1,\"XX11\"\nB += 1,\"XX1X\"\n\njulia> trim(A,2)\n(4.0 + 0.0im) ZZXX\n(3.0 + 0.0im) XX1X\n\njulia> trim(A,2;keep=B)\n(4.0 + 0.0im) ZZXX\n(3.0 + 0.0im) XX1X\n(2.0 + 0.0im) XX11\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"prune(o::Operator, alpha::Real; keepnorm::Bool = false)","category":"page"},{"location":"documentation/#PauliStrings.prune-Tuple{Operator, Real}","page":"Documentation","title":"PauliStrings.prune","text":" prune(o::Operator, alpha::Real; keepnorm::Bool = false)\n\nKeep terms with probability 1-exp(-alpha*abs(c)) where c is the weight of the term\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"cutoff(o::Operator, epsilon::Real; keepnorm::Bool = false)","category":"page"},{"location":"documentation/#PauliStrings.cutoff-Tuple{Operator, Real}","page":"Documentation","title":"PauliStrings.cutoff","text":"cutoff(o::Operator, epsilon::Real; keepnorm::Bool = false)\n\nRemove all terms with weight < epsilon\n\nExample\n\nA = Operator(4)\nA += 1,\"XXXX\"\nA += 2,\"XX11\"\nA += 3,\"XX1X\"\nA += 4,\"ZZXX\"\n\njulia> cutoff(A, 2.5)\n(3.0 + 0.0im) XX1X\n(4.0 + 0.0im) ZZXX\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"add_noise(o::Operator, g::Real)","category":"page"},{"location":"documentation/#PauliStrings.add_noise-Tuple{Operator, Real}","page":"Documentation","title":"PauliStrings.add_noise","text":"add_noise(o::Operator, g::Real)\n\nAdd depolarizing noise that make the long string decays. g is the noise amplitude.\n\nExample\n\nA = add_noise(A, 0.1)\n\nReference\n\nhttps://arxiv.org/pdf/2407.12768\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"k_local_part(o::Operator, k::Int)","category":"page"},{"location":"documentation/#PauliStrings.k_local_part-Tuple{Operator, Int64}","page":"Documentation","title":"PauliStrings.k_local_part","text":"k_local_part(o::Operator, k::Int)\n\nReturn the k-local part of o. I.e all the strings of lenght k.\n\nExample\n\nA = Operator(4)\nA += \"X\",1,\"X\",2\nA += \"Z\",1,\"Z\",2,\"Z\",4\nA += \"1X11\"\n\njulia> A\n(1.0 + 0.0im) ZZ1Z\n(1.0 + 0.0im) 1X11\n(1.0 + 0.0im) XX11\n\njulia> k_local_part(A,2)\n(1.0 + 0.0im) XX11\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Algorithms","page":"Documentation","title":"Algorithms","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"lanczos(H::Operator, O::Operator, steps::Int, nterms::Int; keepnorm=true, maxlength=1000)\nlanczos(H::OperatorTS1D, O::OperatorTS1D, steps::Int, nterms::Int; keepnorm=true, maxlength=1000)","category":"page"},{"location":"documentation/#PauliStrings.lanczos-Tuple{Operator, Operator, Int64, Int64}","page":"Documentation","title":"PauliStrings.lanczos","text":"lanczos(H::Operator, O::Operator, steps::Int, nterms::Int; keepnorm=true, maxlength=1000)\nlanczos(H::OperatorTS1D, O::OperatorTS1D, steps::Int, nterms::Int; keepnorm=true, maxlength=1000)\n\nComputer the first steps lanczos coeficients for Hamiltonian H and initial operator O\n\nAt every step, the operator is trimed with trim and only nterms are kept.\n\nUsing maxlength speeds up the commutator by only keeping terms of length <= maxlength\n\n\n\n\n\n","category":"method"},{"location":"documentation/#PauliStrings.lanczos-Tuple{OperatorTS1D, OperatorTS1D, Int64, Int64}","page":"Documentation","title":"PauliStrings.lanczos","text":"lanczos(H::Operator, O::Operator, steps::Int, nterms::Int; keepnorm=true, maxlength=1000)\nlanczos(H::OperatorTS1D, O::OperatorTS1D, steps::Int, nterms::Int; keepnorm=true, maxlength=1000)\n\nComputer the first steps lanczos coeficients for Hamiltonian H and initial operator O\n\nAt every step, the operator is trimed with trim and only nterms are kept.\n\nUsing maxlength speeds up the commutator by only keeping terms of length <= maxlength\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"rk4(H::Operator, O::Operator, dt::Real; hbar::Real=1, heisenberg=false, M=2^20, keep::Operator=Operator(N))","category":"page"},{"location":"documentation/#PauliStrings.rk4-Tuple{Operator, Operator, Real}","page":"Documentation","title":"PauliStrings.rk4","text":"rk4(H::Operator, O::Operator, dt::Real; hbar::Real=1, heisenberg=false, M=2^20, keep::Operator=Operator(N))\n\nSingle step of Runge–Kutta-4 with time independant Hamiltonian. Returns O(t+dt). Set heisenberg=true for evolving an observable in the heisenberg picture. If heisenberg=false then it is assumed that O is a density matrix.\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"rk4(H::Function, O::Operator, dt::Real, t::Real; hbar::Real=1, heisenberg=false)","category":"page"},{"location":"documentation/#PauliStrings.rk4-Tuple{Function, Operator, Real, Real}","page":"Documentation","title":"PauliStrings.rk4","text":"rk4(H::Function, O::Operator, dt::Real, t::Real; hbar::Real=1, heisenberg=false)\n\nSingle step of Runge–Kutta-4 with time dependant Hamiltonian. H is a function that takes a number (time) and returns an operator.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Tools","page":"Documentation","title":"Tools","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"compress(o::Operator)","category":"page"},{"location":"documentation/#PauliStrings.compress-Tuple{Operator}","page":"Documentation","title":"PauliStrings.compress","text":"compress(o::Operator)\ncompress(o::OperatorTS1D)\n\nAccumulate repeated terms and remove terms with a coeficient smaller than 1e-20\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"op_to_strings(o::Operator)","category":"page"},{"location":"documentation/#PauliStrings.op_to_strings-Tuple{Operator}","page":"Documentation","title":"PauliStrings.op_to_strings","text":"op_to_strings(o::Operator)\n\ntakes an operator, return (coefs, strings) where coefs is a list of numbers and strings is a list of pauli string coefs[i] multiply strings[i]\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"op_to_dense(o::Operator)","category":"page"},{"location":"documentation/#PauliStrings.op_to_dense-Tuple{Operator}","page":"Documentation","title":"PauliStrings.op_to_dense","text":"op_to_dense(o::Operator)\n\nConvert an operator to a dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"shift_left(O::Operator)","category":"page"},{"location":"documentation/#PauliStrings.shift_left-Tuple{Operator}","page":"Documentation","title":"PauliStrings.shift_left","text":"shift_left(O::Operator)\n\nShift evey string left so they start on site 1. This usefull for using translation symmetry in 1D systems\n\nExample\n\nA = Operator(4)\nA += \"XYZ1\"\nA += \"11ZZ\"\nA += \"1XZY\"\nA += \"ZZ11\"\n\njulia> shift_left(A)\n(1.0 - 0.0im) XZY1\n(1.0 - 0.0im) XYZ1\n(2.0 + 0.0im) ZZ11\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"xcount(v::Int, w::Int)","category":"page"},{"location":"documentation/#PauliStrings.xcount-Tuple{Int64, Int64}","page":"Documentation","title":"PauliStrings.xcount","text":"xcount(v::Int, w::Int)\n\nCount the number of X in a string\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"ycount(v::Int, w::Int)","category":"page"},{"location":"documentation/#PauliStrings.ycount-Tuple{Int64, Int64}","page":"Documentation","title":"PauliStrings.ycount","text":"ycount(v::Int, w::Int)\n\nCount the number of Y in a string\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"zcount(v::Int, w::Int)","category":"page"},{"location":"documentation/#PauliStrings.zcount-Tuple{Int64, Int64}","page":"Documentation","title":"PauliStrings.zcount","text":"zcount(v::Int, w::Int)\n\nCount the number of Z in a string\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"all_strings(N::Int)","category":"page"},{"location":"documentation/#PauliStrings.all_strings-Tuple{Int64}","page":"Documentation","title":"PauliStrings.all_strings","text":"all_strings(N::Int)\n\nReturn the sum of all the strings supported on N spins, with coeficients 1\n\n\n\n\n\n","category":"method"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"set_coefs(o::Operator, coefs::Vector{T}) where T <: Number","category":"page"},{"location":"documentation/#PauliStrings.set_coefs-Union{Tuple{T}, Tuple{Operator, Vector{T}}} where T<:Number","page":"Documentation","title":"PauliStrings.set_coefs","text":"set_coefs(o::Operator, coefs::Vector{T}) where T <: Number\n\nSets the coeficient of o to coefs. Inplace.\n\nA = Operator(4)\nA += 2, \"1XXY\"\nA += 3, \"11Z1\"\n\njulia> A\n(3.0 + 0.0im) 11Z1\n(2.0 - 0.0im) 1XXY\njulia> set_coefs(A, [5,6])\njulia> A\n(5.0 + 0.0im) 11Z1\n(6.0 - 0.0im) 1XXY\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"lanczos/#Lanczos","page":"Lanczos","title":"Lanczos","text":"","category":"section"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"Here we show how to use PauliStrings.jl to run the recursion method and compute lanczos coefficients. We will focus on reproducing the X in XX results from figure 2 of Parker 2019.","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"Start by importing PauliStrings :","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"using PauliStrings\nimport PauliStrings as ps","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"Define the XX Hamiltonian H = sum_i X_iX_i+1+Y_iY_i+1 on a 1D chain with periodic boundary conditions","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"function XX(N)\n    H = ps.Operator(N)\n    for j in 1:(N - 1)\n        H += \"X\",j,\"X\",j+1\n        H += \"Z\",j,\"Z\",j+1\n    end\n    H += \"X\",1,\"X\",N\n    H += \"Z\",1,\"Z\",N\n    return H\nend","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"and the X operator sum_i=1^N X_i","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"function X(N)\n    H = ps.Operator(N)\n    for j in 1:N\n        H += \"X\",j\n    end\n    return H\nend","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"Initialize a Hamiltonian and an operator:","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"N = 50 # system size\nH = XX(N) #hamiltonian\nO = X(N) #operator","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"Compute and plot the lanczos coefficients for different truncation. For each level of truncation, we keep only 2^p with the highest weight at each step of the lanczos algorithm.","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"ioff()#pyplot\n# nterms is the max pauli string length\nfor p in (14,16,18,20)\n    @time bs = ps.lanczos(H, O, 20, 2^p; keepnorm=true)\n    plot(bs, label=\"trim: 2^$p\")\nend\nlegend()\nylabel(L\"$b_n$\")\nxlabel(L\"$n$\")\ntitle(\"X in XX, N=$N spins\")\nsavefig(\"lanczos_example.png\")\nshow()","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"(Image: plot)","category":"page"},{"location":"lanczos/#Tacking-advantage-of-translation-symmetry","page":"Lanczos","title":"Tacking advantage of translation symmetry","text":"","category":"section"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"If the problem is 1D and has translation symmetry, we can take advantage of the symmetry to save time and memory. Just pass O and H as OperatorTS1D to  lanczos. For example :","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"Hts = OperatorTS1D(H)\nOts = OperatorTS1D(O)\nbs = ps.lanczos(Hts, Ots, 20, 2^p; keepnorm=true)","category":"page"},{"location":"lanczos/","page":"Lanczos","title":"Lanczos","text":"Check the translation symmetry tutorial.","category":"page"},{"location":"evolution/#Time-evolution","page":"Time evolution","title":"Time evolution","text":"","category":"section"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"Time evolution with PauliStrings.jl is done in the Heisenberg picture because pure states are rank 1 density matrices and low rank density matrices cannot be efficiently encoded as a sum of Pauli strings (Loizeau 2024).","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"The advantage of working with Pauli strings is that noisy systems can be efficiently simulated in this representation (Schuster 2024). Depolarizing noise makes long strings decay, so we can make the simulations tractable by combining noise with truncation.","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"Let's time evolve operator Z_1 in the chaotic spin chain H = sum_i X_iX_i+1-105 Z_i +h_X X_i First we construct the Hamiltonian:","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"using PauliStrings\nimport PauliStrings as ps","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"function chaotic_chain(N::Int)\n    H = ps.Operator(N)\n    # XX interractions\n    for j in 1:(N - 1)\n        H += \"X\",j,\"X\",j+1\n    end\n    H += \"X\",1,\"X\",N # close the chain\n    # fields\n    for j in 1:N\n        H += -1.05,\"Z\",j\n        H += 0.5,\"X\",j\n    end\n    return H\nend","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"We initialize a Hamiltonian and the Z_1 operator on a 32 spins system.","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"N = 32 # system size\nH = chaotic_chain(N) #hamiltonian\nO = ps.Operator(N) #operator to time evolve\nO += \"Z\", 1 # Z on site 1","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"Now we write a function that will time evolve operator O under Hamiltonian H and return some observable. Here we are interested in recording the correlator $ S(t) = \\frac{1}{2^N} \\text{Tr} [Z1(t)Z1(0)] $. We will time evolve O by integrating Von Neuman's equation i fracdOdt=-HO with Runge-Kutta (rk4). At each time step we do 3 things :","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"Perform a rk4 step\nadd_noise that make long strings decay\ntrim O by keeping only M strings with the largest weight","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"# heisenberg evolution of the operator O using rk4\n# return tr(O(0)*O(t))/tr(O(t)^2)\n# M is the number of strings to keep at each step\n# noise is the amplitude of depolarizing noise\nfunction evolve(H, O, M, times, noise)\n    echo = []\n    O0 = deepcopy(O)\n    dt = times[2]-times[1]\n    for t in ProgressBar(times)\n        push!(echo, ps.trace(O*ps.dagger(O0))/ps.trace(O0*O0))\n        #preform one step of rk4, keep only M strings, do not discard O0\n        O = ps.rk4(H, O, dt; heisenberg=true, M=M,  keep=O0)\n        #add depolarizingn oise\n        O = ps.add_noise(O, noise*dt)\n        # keep the M strings with the largest weight. Do not discard O0\n        O = ps.trim(O, M; keep=O0)\n    end\n    return real.(echo)\nend","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"Now we can actually time evolve O for different trim values and plot the result:","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"# time evolve O for different trim values\ntimes = range(0, stop=5, step=0.05)\nnoise = 0.01\nfor trim in (10,12,14)\n    S = evolve(H, O, 2^trim, times, noise)\n    loglog(times, S) #plot S(t)\nend\n\nlegend()\ntitle(\"N=$N\")\nxlabel(\"t\")\nylabel(L\"tr$(Z_1(0)*Z_1(t))$\")\nsavefig(\"time_evolve_example.png\")\nshow()","category":"page"},{"location":"evolution/","page":"Time evolution","title":"Time evolution","text":"(Image: plot)","category":"page"},{"location":"translation/#translation","page":"Translation symmetry","title":"Translation symmetry in 1D with OperatorTS1D","text":"","category":"section"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Here we will show how to take advantage of translation symmetry to save time and memory in PauliStrings.jl. Consider the 1D Ising Hamiltonian with periodic boundary conditions H=-J(sum_iZ_i Z_i+1 +g sum_i X_i). There is no need to actually store all the Pauli strings in this case. H is fully specified by just -JZ_1Z_2 and -Jg X_1 and the fact that it's translation symmetric.","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"In general, a 1D translation symmetric operator can be written as sum_i T_i H_0 where T_i is the i-sites translation operator and H_0's is the local operator that generates H. H_0 can be chosen so that it's only composed of Pauli strings that start on the first site.","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"In PauliStrings.jl, the structure OperatorTS1D lets you manipulate operators in this format. If your problem is 1D translation symmetric, OperatorTS1D will be much faster than Operator.","category":"page"},{"location":"translation/#Construction","page":"Translation symmetry","title":"Construction","text":"","category":"section"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"There are two ways of constructing an OperatorTS1D :","category":"page"},{"location":"translation/#From-the-full-translation-symmetric-H","page":"Translation symmetry","title":"From the full translation symmetric H","text":"","category":"section"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"First we construct the full Operator:","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"function ising1D(N, J, g)\n    H = Operator(N)\n    for j in 1:(N - 1)\n        H += \"Z\",j,\"Z\",j+1\n    end\n    H += \"Z\",1,\"Z\",N #periodic boundary condition\n    for j in 1:N\n        H += g,\"X\",j\n    end\n    return -J*H\nend\nH = ising1D(N, J, g)","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"then convert it to an OperatorTS1D","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Hts = OperatorTS1D(H)","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"If H is not translation symmetric, then an error will be returned","category":"page"},{"location":"translation/#From-the-local-generator-H_0","page":"Translation symmetry","title":"From the local generator H_0","text":"","category":"section"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Construct H_0 using Operator:","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"H = Operator(N)\nH += -J, \"Z\",1,\"Z\",2\nH += -J*g,\"X\",1","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"then convert it to an OperatorTS1D","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Hts = OperatorTS1D(H, full=false)","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Note that here, we need to set full=false in order to specify that we are not passing the full Hamiltonian but just its local generator.","category":"page"},{"location":"translation/#Manipulation","page":"Translation symmetry","title":"Manipulation","text":"","category":"section"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"All the operations defined on Operator are also defined on OperatorTS1D.","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Construct a simple translation invariant operator on 4 sites:","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"H = Operator(N)\nH += \"X\", 1\nH += \"Z\", 1,\"Z\", 2\n\nHts = OperatorTS1D(H, full=false)\n\nprintln(H)\nprintln(Operator(Hts))","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"(1.0 + 0.0im) X111\n(1.0 + 0.0im) ZZ11\n\n(1.0 + 0.0im) 1ZZ1\n(1.0 + 0.0im) 1X11\n(1.0 + 0.0im) X111\n(1.0 + 0.0im) Z11Z\n(1.0 + 0.0im) 11ZZ\n(1.0 + 0.0im) 11X1\n(1.0 + 0.0im) ZZ11\n(1.0 + 0.0im) 111X","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Note that only the local generator is printed when printing OperatorTS1D, not the full operator.","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Multiplication :","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"julia> Hts*Hts\n(1.0 + 0.0im) X1X1\n(2.0 + 0.0im) Z1Z1\n(2.0 + 0.0im) 1111\n(1.0 + 0.0im) ZZZZ\n(2.0 + 0.0im) XZZ1\n(2.0 + 0.0im) XX11\n(2.0 + 0.0im) ZZX1","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Adition","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"julia> Hts+Hts\n(2.0 + 0.0im) X111\n(2.0 + 0.0im) ZZ11","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"etc..","category":"page"},{"location":"translation/#Example:-computing-Tr(Hk)","page":"Translation symmetry","title":"Example: computing Tr(H^k)","text":"","category":"section"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"As an example of performance gains of using OperatorTS1D instead of Operator we compute the 8th moment (Tr(H^8)) of a 30 spin system.","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"Using the function defined above we construct a Ising Hamiltonian and convert it to an OperatorTS1D:","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"N = 30\nk = 8\nH = ising1D(N, 1)\nHts = OperatorTS1D(H)","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"then we compute the kth moment (trace_product) using both Operator and OperatorTS1D :","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"julia> @time println(trace_product(H, k))\n1.1904927790006272e18 + 0.0im\n 80.697013 seconds (28.91 k allocations: 111.213 MiB, 0.07% gc time, 0.04% compilation time)\n\njulia> @time println(trace_product(Hts, k))\n1.190492779000627e18 + 0.0im\n  1.951678 seconds (37.09 k allocations: 36.165 MiB, 2.00% gc time, 2.01% compilation time)","category":"page"},{"location":"translation/","page":"Translation symmetry","title":"Translation symmetry","text":"OperatorTS1D is 40 times faster in this case.","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"(Image: Build Status) (Image: ) (Image: )","category":"page"},{"location":"#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"PauliStrings.jl is a Julia package for many-body quantum mechanics with Pauli string represented as binary integers. It is particularly adapted for running Lanczos, time evolving noisy systems and simulating spin systems on arbitrary graphs. Paper : https://arxiv.org/abs/2410.09654","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"(Image: gif)","category":"page"},{"location":"#[Documentation](https://nicolasloizeau.github.io/PauliStrings.jl/dev/)","page":"Getting started","title":"Documentation","text":"","category":"section"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"using Pkg; Pkg.add(PauliStrings) or ] add PauliStrings","category":"page"},{"location":"#Initializing-an-operator","page":"Getting started","title":"Initializing an operator","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Import the library and initialize a operator of 4 qubits","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"using PauliStrings\nimport PauliStrings as ps\nH = ps.Operator(4)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Add a Pauli strings to the operator","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"H += \"XYZ1\"\nH += \"1YZY\"","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"julia> H\n(1.0 - 0.0im) XYZ1\n(1.0 - 0.0im) 1YZY","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Add a Pauli string with a coeficient","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"H += -1.2,\"XXXZ\" #coeficient can be complex","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Add a 2-qubit string coupling qubits i and j with X and Y:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"H += 2, \"X\", i, \"Y\", j # with a coeficient=2\nH += \"X\", i, \"Y\", j # with a coeficient=1","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Add a 1-qubit string:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"H += 2, \"Z\", i # with a coeficient=2\nH += \"Z\", i # with a coeficient=1\nH += \"S+\", i","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Supported sites operators are X, Y, Z, Sx=X2, Sy=Y2, Sz=Z2, S+=(X+iY)2, S-=(X-iY)2.","category":"page"},{"location":"#Basic-Algebra","page":"Getting started","title":"Basic Algebra","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"The Operator type supports the +,-,* operators with other Operators and Numbers:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"H3 = H1*H2\nH3 = H1+H2\nH3 = H1-H2\nH3 = H1+2 # adding a scalar is equivalent to adding the unit times the scalar\nH = 5*H # multiply operator by a scalar","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Trace : ps.trace(H)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Frobenius norm : ps.opnorm(H)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Conjugate transpose : ps.dagger(H)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Number of terms: length(H)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Commutator: ps.com(H1, H2). This is much faster than H1*H2-H2*H1","category":"page"},{"location":"#Print-and-export","page":"Getting started","title":"Print and export","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"print shows a list of terms with coeficients e.g :","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"julia> println(H)\n(10.0 - 0.0im) 1ZZ\n(5.0 - 0.0im) 1Z1\n(15.0 + 0.0im) XYZ\n(5.0 + 0.0im) 1YY","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Export a list of strings with coeficients:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"coefs, strings = ps.op_to_strings(H)","category":"page"},{"location":"#Truncate,-Cutoff,-Trim,-Noise","page":"Getting started","title":"Truncate, Cutoff, Trim, Noise","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"ps.truncate(H,M) removes Pauli strings longer than M (returns a new Operator) ps.cutoff(H,c) removes Pauli strings with coeficient smaller than c in absolute value (returns a new Operator) ps.trim(H,N) keeps the first N trings with higest weight (returns a new Operator) ps.prune(H,alpha) keeps terms with probability 1-exp(-alpha*abs(c)) (returns a new Operator)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"ps.add_noise(H,g) adds depolarizing noise that make each strings decay like e^gw where w is the lenght of the string. This is usefull when used with trim to keep the number of strings manageable during time evolution.","category":"page"},{"location":"#Time-evolution","page":"Getting started","title":"Time evolution","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"ps.rk4(H, O, dt; hbar=1, heisenberg=false) performs a step of Runge Kutta and returns the new updated O(t+dt)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"H can be an Operator, or a function that takes a time and return an Operator. In case H is a function, a time also needs to be passed to rk4(H, O, dt, t). O is an Observable or a density matrix to time evolve. If evolving an observable in the heisenberg picture, set heisenberg=true.","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"An example is in time_evolve_example.jl. The following will time evolve O in the Heisenberg picture. At each step, we add depolarizing noise and trim the operator to keep the number of strings manageable","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"function evolve(H, O, M, times, noise)\n    dt = times[2]-times[1]\n    for t in times\n        O = ps.rk4(H, O, dt; heisenberg=true, M=M) #preform one step of rk4, keep only M strings\n        O = ps.add_noise(O, noise*dt) #add depolarizingn noise\n        O = ps.trim(O, M) # keep the M strings with the largest weight\n    end\n    return O\nend","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Time evolution of the spin correlation function textupTr(Z_1(0)Z_1(t)) in the chaotic spin chain. Check timeevolveexample.jl to reproduce the plot. (Image: plot)","category":"page"},{"location":"#Lanczos","page":"Getting started","title":"Lanczos","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Compute lanczos coeficients","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"bs = ps.lanczos(H, O, steps, nterms)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"H : Hamiltonian","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"O : starting operator","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"nterms : maximum number of terms in the operator. Used by trim at every step","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Results for X in XX from https://journals.aps.org/prx/pdf/10.1103/PhysRevX.9.041017 :","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"(Image: plot)","category":"page"},{"location":"#Contact","page":"Getting started","title":"Contact","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"For questions and suggestions : nicolas.loizeau@nbi.ku.dk","category":"page"},{"location":"#Citation","page":"Getting started","title":"Citation","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"@misc{loizeau2024,\n      title={Quantum many-body simulations with PauliStrings.jl},\n      author={Nicolas Loizeau and J. Clayton Peacock and Dries Sels},\n      year={2024},\n      eprint={2410.09654},\n      archivePrefix={arXiv},\n      primaryClass={quant-ph},\n      url={https://arxiv.org/abs/2410.09654},\n}","category":"page"},{"location":"constructing/#Constructing-operators","page":"Constructing operators","title":"Constructing operators","text":"","category":"section"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Start by importing PauliStrings :","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"using PauliStrings\nimport PauliStrings as ps","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"To construct an operator we first need to declare an empty operator of N qubits :","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"H = Operator(N)","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"For the moment, PauliStrings.jl supports a maximum of 64 qubits.","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"We can add a term of the form J X_i by doing","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"H += J, \"X\", i","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"and a term of the form J X_iX_j by doing","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"H += J, \"X\", i, \"X\", j","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Similarly, we add a term of the form J X_iX_jX_k by doing","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"H += J, \"X\", i, \"X\", j, \"X\", k","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"etc.","category":"page"},{"location":"constructing/#1D-transverse-ising-model","page":"Constructing operators","title":"1D transverse ising model","text":"","category":"section"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Lets construct the Hamiltonian of a 1D transverse ising model H=-J(sum_ijZ_i Z_j +g sum_i X_i)","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"function ising1D(N, J, g)\n    H = Operator(N)\n    for j in 1:(N - 1)\n        H += \"Z\",j,\"Z\",j+1\n    end\n    H += \"Z\",1,\"Z\",N #periodic boundary condition\n    for j in 1:N\n        H += g,\"X\",j\n    end\n    return -J*H\nend","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Note that the first qubit starts at index 1, following Julia's 1-based index.","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Operators can be printed in strings format with the println function:","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"julia> println(ising1D(3, 1, 0.5))\n(-1.0 + 0.0im) Z1Z\n(-1.0 + 0.0im) 1ZZ\n(-0.5 + 0.0im) 1X1\n(-0.5 + 0.0im) X11\n(-1.0 + 0.0im) ZZ1\n(-0.5 + 0.0im) 11X","category":"page"},{"location":"constructing/#2D-transverse-ising-model","page":"Constructing operators","title":"2D transverse ising model","text":"","category":"section"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"Here we construct a 2D ising model on a square lattice of L*L sites, with no periodic boundary conditions.","category":"page"},{"location":"constructing/","page":"Constructing operators","title":"Constructing operators","text":"function ising2D(L, J, g)\n    H = ps.Operator(L*L)\n    for x in 1:L-1\n        for y in 1:L\n            # convert x,y to qubit index\n            i = L*(y-1)+x\n            j = L*(y-1)+(x+1)\n            # horizontal interaction terms\n            H += ('Z',i,'Z',j)\n            # convert x,y to qubit index\n            i = L*(x-1)+y\n            j = L*x+y\n            # vertical interaction terms\n            H += ('Z',i,'Z',j)\n        end\n    end\n    for j in 1:L*L\n        H += g,\"X\",j\n    end\n    return -J*H\nend","category":"page"},{"location":"docstrings/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docstrings/","page":"Index","title":"Index","text":"","category":"page"}]
}
